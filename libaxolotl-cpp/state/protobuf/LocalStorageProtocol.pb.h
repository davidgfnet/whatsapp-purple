// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protobuf/LocalStorageProtocol.proto

#ifndef PROTOBUF_protobuf_2fLocalStorageProtocol_2eproto__INCLUDED
#define PROTOBUF_protobuf_2fLocalStorageProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace textsecure {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

class SessionStructure;
class SessionStructure_Chain;
class SessionStructure_Chain_ChainKey;
class SessionStructure_Chain_MessageKey;
class SessionStructure_PendingKeyExchange;
class SessionStructure_PendingPreKey;
class RecordStructure;
class PreKeyRecordStructure;
class SignedPreKeyRecordStructure;
class IdentityKeyPairStructure;
class SenderKeyStateStructure;
class SenderKeyStateStructure_SenderChainKey;
class SenderKeyStateStructure_SenderMessageKey;
class SenderKeyStateStructure_SenderSigningKey;
class SenderKeyRecordStructure;

// ===================================================================

class SessionStructure_Chain_ChainKey : public ::google::protobuf::Message {
 public:
  SessionStructure_Chain_ChainKey();
  virtual ~SessionStructure_Chain_ChainKey();

  SessionStructure_Chain_ChainKey(const SessionStructure_Chain_ChainKey& from);

  inline SessionStructure_Chain_ChainKey& operator=(const SessionStructure_Chain_ChainKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStructure_Chain_ChainKey& default_instance();

  void Swap(SessionStructure_Chain_ChainKey* other);

  // implements Message ----------------------------------------------

  SessionStructure_Chain_ChainKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStructure_Chain_ChainKey& from);
  void MergeFrom(const SessionStructure_Chain_ChainKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:textsecure.SessionStructure.Chain.ChainKey)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SessionStructure_Chain_ChainKey* default_instance_;
};
// -------------------------------------------------------------------

class SessionStructure_Chain_MessageKey : public ::google::protobuf::Message {
 public:
  SessionStructure_Chain_MessageKey();
  virtual ~SessionStructure_Chain_MessageKey();

  SessionStructure_Chain_MessageKey(const SessionStructure_Chain_MessageKey& from);

  inline SessionStructure_Chain_MessageKey& operator=(const SessionStructure_Chain_MessageKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStructure_Chain_MessageKey& default_instance();

  void Swap(SessionStructure_Chain_MessageKey* other);

  // implements Message ----------------------------------------------

  SessionStructure_Chain_MessageKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStructure_Chain_MessageKey& from);
  void MergeFrom(const SessionStructure_Chain_MessageKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional bytes cipherKey = 2;
  inline bool has_cipherkey() const;
  inline void clear_cipherkey();
  static const int kCipherKeyFieldNumber = 2;
  inline const ::std::string& cipherkey() const;
  inline void set_cipherkey(const ::std::string& value);
  inline void set_cipherkey(const char* value);
  inline void set_cipherkey(const void* value, size_t size);
  inline ::std::string* mutable_cipherkey();
  inline ::std::string* release_cipherkey();
  inline void set_allocated_cipherkey(::std::string* cipherkey);

  // optional bytes macKey = 3;
  inline bool has_mackey() const;
  inline void clear_mackey();
  static const int kMacKeyFieldNumber = 3;
  inline const ::std::string& mackey() const;
  inline void set_mackey(const ::std::string& value);
  inline void set_mackey(const char* value);
  inline void set_mackey(const void* value, size_t size);
  inline ::std::string* mutable_mackey();
  inline ::std::string* release_mackey();
  inline void set_allocated_mackey(::std::string* mackey);

  // optional bytes iv = 4;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 4;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // @@protoc_insertion_point(class_scope:textsecure.SessionStructure.Chain.MessageKey)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_cipherkey();
  inline void clear_has_cipherkey();
  inline void set_has_mackey();
  inline void clear_has_mackey();
  inline void set_has_iv();
  inline void clear_has_iv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cipherkey_;
  ::std::string* mackey_;
  ::std::string* iv_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SessionStructure_Chain_MessageKey* default_instance_;
};
// -------------------------------------------------------------------

class SessionStructure_Chain : public ::google::protobuf::Message {
 public:
  SessionStructure_Chain();
  virtual ~SessionStructure_Chain();

  SessionStructure_Chain(const SessionStructure_Chain& from);

  inline SessionStructure_Chain& operator=(const SessionStructure_Chain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStructure_Chain& default_instance();

  void Swap(SessionStructure_Chain* other);

  // implements Message ----------------------------------------------

  SessionStructure_Chain* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStructure_Chain& from);
  void MergeFrom(const SessionStructure_Chain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SessionStructure_Chain_ChainKey ChainKey;
  typedef SessionStructure_Chain_MessageKey MessageKey;

  // accessors -------------------------------------------------------

  // optional bytes senderRatchetKey = 1;
  inline bool has_senderratchetkey() const;
  inline void clear_senderratchetkey();
  static const int kSenderRatchetKeyFieldNumber = 1;
  inline const ::std::string& senderratchetkey() const;
  inline void set_senderratchetkey(const ::std::string& value);
  inline void set_senderratchetkey(const char* value);
  inline void set_senderratchetkey(const void* value, size_t size);
  inline ::std::string* mutable_senderratchetkey();
  inline ::std::string* release_senderratchetkey();
  inline void set_allocated_senderratchetkey(::std::string* senderratchetkey);

  // optional bytes senderRatchetKeyPrivate = 2;
  inline bool has_senderratchetkeyprivate() const;
  inline void clear_senderratchetkeyprivate();
  static const int kSenderRatchetKeyPrivateFieldNumber = 2;
  inline const ::std::string& senderratchetkeyprivate() const;
  inline void set_senderratchetkeyprivate(const ::std::string& value);
  inline void set_senderratchetkeyprivate(const char* value);
  inline void set_senderratchetkeyprivate(const void* value, size_t size);
  inline ::std::string* mutable_senderratchetkeyprivate();
  inline ::std::string* release_senderratchetkeyprivate();
  inline void set_allocated_senderratchetkeyprivate(::std::string* senderratchetkeyprivate);

  // optional .textsecure.SessionStructure.Chain.ChainKey chainKey = 3;
  inline bool has_chainkey() const;
  inline void clear_chainkey();
  static const int kChainKeyFieldNumber = 3;
  inline const ::textsecure::SessionStructure_Chain_ChainKey& chainkey() const;
  inline ::textsecure::SessionStructure_Chain_ChainKey* mutable_chainkey();
  inline ::textsecure::SessionStructure_Chain_ChainKey* release_chainkey();
  inline void set_allocated_chainkey(::textsecure::SessionStructure_Chain_ChainKey* chainkey);

  // repeated .textsecure.SessionStructure.Chain.MessageKey messageKeys = 4;
  inline int messagekeys_size() const;
  inline void clear_messagekeys();
  static const int kMessageKeysFieldNumber = 4;
  inline const ::textsecure::SessionStructure_Chain_MessageKey& messagekeys(int index) const;
  inline ::textsecure::SessionStructure_Chain_MessageKey* mutable_messagekeys(int index);
  inline ::textsecure::SessionStructure_Chain_MessageKey* add_messagekeys();
  inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain_MessageKey >&
      messagekeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain_MessageKey >*
      mutable_messagekeys();

  // @@protoc_insertion_point(class_scope:textsecure.SessionStructure.Chain)
 private:
  inline void set_has_senderratchetkey();
  inline void clear_has_senderratchetkey();
  inline void set_has_senderratchetkeyprivate();
  inline void clear_has_senderratchetkeyprivate();
  inline void set_has_chainkey();
  inline void clear_has_chainkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* senderratchetkey_;
  ::std::string* senderratchetkeyprivate_;
  ::textsecure::SessionStructure_Chain_ChainKey* chainkey_;
  ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain_MessageKey > messagekeys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SessionStructure_Chain* default_instance_;
};
// -------------------------------------------------------------------

class SessionStructure_PendingKeyExchange : public ::google::protobuf::Message {
 public:
  SessionStructure_PendingKeyExchange();
  virtual ~SessionStructure_PendingKeyExchange();

  SessionStructure_PendingKeyExchange(const SessionStructure_PendingKeyExchange& from);

  inline SessionStructure_PendingKeyExchange& operator=(const SessionStructure_PendingKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStructure_PendingKeyExchange& default_instance();

  void Swap(SessionStructure_PendingKeyExchange* other);

  // implements Message ----------------------------------------------

  SessionStructure_PendingKeyExchange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStructure_PendingKeyExchange& from);
  void MergeFrom(const SessionStructure_PendingKeyExchange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sequence = 1;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional bytes localBaseKey = 2;
  inline bool has_localbasekey() const;
  inline void clear_localbasekey();
  static const int kLocalBaseKeyFieldNumber = 2;
  inline const ::std::string& localbasekey() const;
  inline void set_localbasekey(const ::std::string& value);
  inline void set_localbasekey(const char* value);
  inline void set_localbasekey(const void* value, size_t size);
  inline ::std::string* mutable_localbasekey();
  inline ::std::string* release_localbasekey();
  inline void set_allocated_localbasekey(::std::string* localbasekey);

  // optional bytes localBaseKeyPrivate = 3;
  inline bool has_localbasekeyprivate() const;
  inline void clear_localbasekeyprivate();
  static const int kLocalBaseKeyPrivateFieldNumber = 3;
  inline const ::std::string& localbasekeyprivate() const;
  inline void set_localbasekeyprivate(const ::std::string& value);
  inline void set_localbasekeyprivate(const char* value);
  inline void set_localbasekeyprivate(const void* value, size_t size);
  inline ::std::string* mutable_localbasekeyprivate();
  inline ::std::string* release_localbasekeyprivate();
  inline void set_allocated_localbasekeyprivate(::std::string* localbasekeyprivate);

  // optional bytes localRatchetKey = 4;
  inline bool has_localratchetkey() const;
  inline void clear_localratchetkey();
  static const int kLocalRatchetKeyFieldNumber = 4;
  inline const ::std::string& localratchetkey() const;
  inline void set_localratchetkey(const ::std::string& value);
  inline void set_localratchetkey(const char* value);
  inline void set_localratchetkey(const void* value, size_t size);
  inline ::std::string* mutable_localratchetkey();
  inline ::std::string* release_localratchetkey();
  inline void set_allocated_localratchetkey(::std::string* localratchetkey);

  // optional bytes localRatchetKeyPrivate = 5;
  inline bool has_localratchetkeyprivate() const;
  inline void clear_localratchetkeyprivate();
  static const int kLocalRatchetKeyPrivateFieldNumber = 5;
  inline const ::std::string& localratchetkeyprivate() const;
  inline void set_localratchetkeyprivate(const ::std::string& value);
  inline void set_localratchetkeyprivate(const char* value);
  inline void set_localratchetkeyprivate(const void* value, size_t size);
  inline ::std::string* mutable_localratchetkeyprivate();
  inline ::std::string* release_localratchetkeyprivate();
  inline void set_allocated_localratchetkeyprivate(::std::string* localratchetkeyprivate);

  // optional bytes localIdentityKey = 7;
  inline bool has_localidentitykey() const;
  inline void clear_localidentitykey();
  static const int kLocalIdentityKeyFieldNumber = 7;
  inline const ::std::string& localidentitykey() const;
  inline void set_localidentitykey(const ::std::string& value);
  inline void set_localidentitykey(const char* value);
  inline void set_localidentitykey(const void* value, size_t size);
  inline ::std::string* mutable_localidentitykey();
  inline ::std::string* release_localidentitykey();
  inline void set_allocated_localidentitykey(::std::string* localidentitykey);

  // optional bytes localIdentityKeyPrivate = 8;
  inline bool has_localidentitykeyprivate() const;
  inline void clear_localidentitykeyprivate();
  static const int kLocalIdentityKeyPrivateFieldNumber = 8;
  inline const ::std::string& localidentitykeyprivate() const;
  inline void set_localidentitykeyprivate(const ::std::string& value);
  inline void set_localidentitykeyprivate(const char* value);
  inline void set_localidentitykeyprivate(const void* value, size_t size);
  inline ::std::string* mutable_localidentitykeyprivate();
  inline ::std::string* release_localidentitykeyprivate();
  inline void set_allocated_localidentitykeyprivate(::std::string* localidentitykeyprivate);

  // @@protoc_insertion_point(class_scope:textsecure.SessionStructure.PendingKeyExchange)
 private:
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_localbasekey();
  inline void clear_has_localbasekey();
  inline void set_has_localbasekeyprivate();
  inline void clear_has_localbasekeyprivate();
  inline void set_has_localratchetkey();
  inline void clear_has_localratchetkey();
  inline void set_has_localratchetkeyprivate();
  inline void clear_has_localratchetkeyprivate();
  inline void set_has_localidentitykey();
  inline void clear_has_localidentitykey();
  inline void set_has_localidentitykeyprivate();
  inline void clear_has_localidentitykeyprivate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* localbasekey_;
  ::std::string* localbasekeyprivate_;
  ::std::string* localratchetkey_;
  ::std::string* localratchetkeyprivate_;
  ::std::string* localidentitykey_;
  ::std::string* localidentitykeyprivate_;
  ::google::protobuf::uint32 sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SessionStructure_PendingKeyExchange* default_instance_;
};
// -------------------------------------------------------------------

class SessionStructure_PendingPreKey : public ::google::protobuf::Message {
 public:
  SessionStructure_PendingPreKey();
  virtual ~SessionStructure_PendingPreKey();

  SessionStructure_PendingPreKey(const SessionStructure_PendingPreKey& from);

  inline SessionStructure_PendingPreKey& operator=(const SessionStructure_PendingPreKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStructure_PendingPreKey& default_instance();

  void Swap(SessionStructure_PendingPreKey* other);

  // implements Message ----------------------------------------------

  SessionStructure_PendingPreKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStructure_PendingPreKey& from);
  void MergeFrom(const SessionStructure_PendingPreKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 preKeyId = 1;
  inline bool has_prekeyid() const;
  inline void clear_prekeyid();
  static const int kPreKeyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 prekeyid() const;
  inline void set_prekeyid(::google::protobuf::uint32 value);

  // optional int32 signedPreKeyId = 3;
  inline bool has_signedprekeyid() const;
  inline void clear_signedprekeyid();
  static const int kSignedPreKeyIdFieldNumber = 3;
  inline ::google::protobuf::int32 signedprekeyid() const;
  inline void set_signedprekeyid(::google::protobuf::int32 value);

  // optional bytes baseKey = 2;
  inline bool has_basekey() const;
  inline void clear_basekey();
  static const int kBaseKeyFieldNumber = 2;
  inline const ::std::string& basekey() const;
  inline void set_basekey(const ::std::string& value);
  inline void set_basekey(const char* value);
  inline void set_basekey(const void* value, size_t size);
  inline ::std::string* mutable_basekey();
  inline ::std::string* release_basekey();
  inline void set_allocated_basekey(::std::string* basekey);

  // @@protoc_insertion_point(class_scope:textsecure.SessionStructure.PendingPreKey)
 private:
  inline void set_has_prekeyid();
  inline void clear_has_prekeyid();
  inline void set_has_signedprekeyid();
  inline void clear_has_signedprekeyid();
  inline void set_has_basekey();
  inline void clear_has_basekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 prekeyid_;
  ::google::protobuf::int32 signedprekeyid_;
  ::std::string* basekey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SessionStructure_PendingPreKey* default_instance_;
};
// -------------------------------------------------------------------

class SessionStructure : public ::google::protobuf::Message {
 public:
  SessionStructure();
  virtual ~SessionStructure();

  SessionStructure(const SessionStructure& from);

  inline SessionStructure& operator=(const SessionStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStructure& default_instance();

  void Swap(SessionStructure* other);

  // implements Message ----------------------------------------------

  SessionStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStructure& from);
  void MergeFrom(const SessionStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SessionStructure_Chain Chain;
  typedef SessionStructure_PendingKeyExchange PendingKeyExchange;
  typedef SessionStructure_PendingPreKey PendingPreKey;

  // accessors -------------------------------------------------------

  // optional uint32 sessionVersion = 1;
  inline bool has_sessionversion() const;
  inline void clear_sessionversion();
  static const int kSessionVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 sessionversion() const;
  inline void set_sessionversion(::google::protobuf::uint32 value);

  // optional bytes localIdentityPublic = 2;
  inline bool has_localidentitypublic() const;
  inline void clear_localidentitypublic();
  static const int kLocalIdentityPublicFieldNumber = 2;
  inline const ::std::string& localidentitypublic() const;
  inline void set_localidentitypublic(const ::std::string& value);
  inline void set_localidentitypublic(const char* value);
  inline void set_localidentitypublic(const void* value, size_t size);
  inline ::std::string* mutable_localidentitypublic();
  inline ::std::string* release_localidentitypublic();
  inline void set_allocated_localidentitypublic(::std::string* localidentitypublic);

  // optional bytes remoteIdentityPublic = 3;
  inline bool has_remoteidentitypublic() const;
  inline void clear_remoteidentitypublic();
  static const int kRemoteIdentityPublicFieldNumber = 3;
  inline const ::std::string& remoteidentitypublic() const;
  inline void set_remoteidentitypublic(const ::std::string& value);
  inline void set_remoteidentitypublic(const char* value);
  inline void set_remoteidentitypublic(const void* value, size_t size);
  inline ::std::string* mutable_remoteidentitypublic();
  inline ::std::string* release_remoteidentitypublic();
  inline void set_allocated_remoteidentitypublic(::std::string* remoteidentitypublic);

  // optional bytes rootKey = 4;
  inline bool has_rootkey() const;
  inline void clear_rootkey();
  static const int kRootKeyFieldNumber = 4;
  inline const ::std::string& rootkey() const;
  inline void set_rootkey(const ::std::string& value);
  inline void set_rootkey(const char* value);
  inline void set_rootkey(const void* value, size_t size);
  inline ::std::string* mutable_rootkey();
  inline ::std::string* release_rootkey();
  inline void set_allocated_rootkey(::std::string* rootkey);

  // optional uint32 previousCounter = 5;
  inline bool has_previouscounter() const;
  inline void clear_previouscounter();
  static const int kPreviousCounterFieldNumber = 5;
  inline ::google::protobuf::uint32 previouscounter() const;
  inline void set_previouscounter(::google::protobuf::uint32 value);

  // optional .textsecure.SessionStructure.Chain senderChain = 6;
  inline bool has_senderchain() const;
  inline void clear_senderchain();
  static const int kSenderChainFieldNumber = 6;
  inline const ::textsecure::SessionStructure_Chain& senderchain() const;
  inline ::textsecure::SessionStructure_Chain* mutable_senderchain();
  inline ::textsecure::SessionStructure_Chain* release_senderchain();
  inline void set_allocated_senderchain(::textsecure::SessionStructure_Chain* senderchain);

  // repeated .textsecure.SessionStructure.Chain receiverChains = 7;
  inline int receiverchains_size() const;
  inline void clear_receiverchains();
  static const int kReceiverChainsFieldNumber = 7;
  inline const ::textsecure::SessionStructure_Chain& receiverchains(int index) const;
  inline ::textsecure::SessionStructure_Chain* mutable_receiverchains(int index);
  inline ::textsecure::SessionStructure_Chain* add_receiverchains();
  inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain >&
      receiverchains() const;
  inline ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain >*
      mutable_receiverchains();

  // optional .textsecure.SessionStructure.PendingKeyExchange pendingKeyExchange = 8;
  inline bool has_pendingkeyexchange() const;
  inline void clear_pendingkeyexchange();
  static const int kPendingKeyExchangeFieldNumber = 8;
  inline const ::textsecure::SessionStructure_PendingKeyExchange& pendingkeyexchange() const;
  inline ::textsecure::SessionStructure_PendingKeyExchange* mutable_pendingkeyexchange();
  inline ::textsecure::SessionStructure_PendingKeyExchange* release_pendingkeyexchange();
  inline void set_allocated_pendingkeyexchange(::textsecure::SessionStructure_PendingKeyExchange* pendingkeyexchange);

  // optional .textsecure.SessionStructure.PendingPreKey pendingPreKey = 9;
  inline bool has_pendingprekey() const;
  inline void clear_pendingprekey();
  static const int kPendingPreKeyFieldNumber = 9;
  inline const ::textsecure::SessionStructure_PendingPreKey& pendingprekey() const;
  inline ::textsecure::SessionStructure_PendingPreKey* mutable_pendingprekey();
  inline ::textsecure::SessionStructure_PendingPreKey* release_pendingprekey();
  inline void set_allocated_pendingprekey(::textsecure::SessionStructure_PendingPreKey* pendingprekey);

  // optional uint32 remoteRegistrationId = 10;
  inline bool has_remoteregistrationid() const;
  inline void clear_remoteregistrationid();
  static const int kRemoteRegistrationIdFieldNumber = 10;
  inline ::google::protobuf::uint32 remoteregistrationid() const;
  inline void set_remoteregistrationid(::google::protobuf::uint32 value);

  // optional uint32 localRegistrationId = 11;
  inline bool has_localregistrationid() const;
  inline void clear_localregistrationid();
  static const int kLocalRegistrationIdFieldNumber = 11;
  inline ::google::protobuf::uint32 localregistrationid() const;
  inline void set_localregistrationid(::google::protobuf::uint32 value);

  // optional bool needsRefresh = 12;
  inline bool has_needsrefresh() const;
  inline void clear_needsrefresh();
  static const int kNeedsRefreshFieldNumber = 12;
  inline bool needsrefresh() const;
  inline void set_needsrefresh(bool value);

  // optional bytes aliceBaseKey = 13;
  inline bool has_alicebasekey() const;
  inline void clear_alicebasekey();
  static const int kAliceBaseKeyFieldNumber = 13;
  inline const ::std::string& alicebasekey() const;
  inline void set_alicebasekey(const ::std::string& value);
  inline void set_alicebasekey(const char* value);
  inline void set_alicebasekey(const void* value, size_t size);
  inline ::std::string* mutable_alicebasekey();
  inline ::std::string* release_alicebasekey();
  inline void set_allocated_alicebasekey(::std::string* alicebasekey);

  // @@protoc_insertion_point(class_scope:textsecure.SessionStructure)
 private:
  inline void set_has_sessionversion();
  inline void clear_has_sessionversion();
  inline void set_has_localidentitypublic();
  inline void clear_has_localidentitypublic();
  inline void set_has_remoteidentitypublic();
  inline void clear_has_remoteidentitypublic();
  inline void set_has_rootkey();
  inline void clear_has_rootkey();
  inline void set_has_previouscounter();
  inline void clear_has_previouscounter();
  inline void set_has_senderchain();
  inline void clear_has_senderchain();
  inline void set_has_pendingkeyexchange();
  inline void clear_has_pendingkeyexchange();
  inline void set_has_pendingprekey();
  inline void clear_has_pendingprekey();
  inline void set_has_remoteregistrationid();
  inline void clear_has_remoteregistrationid();
  inline void set_has_localregistrationid();
  inline void clear_has_localregistrationid();
  inline void set_has_needsrefresh();
  inline void clear_has_needsrefresh();
  inline void set_has_alicebasekey();
  inline void clear_has_alicebasekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* localidentitypublic_;
  ::std::string* remoteidentitypublic_;
  ::google::protobuf::uint32 sessionversion_;
  ::google::protobuf::uint32 previouscounter_;
  ::std::string* rootkey_;
  ::textsecure::SessionStructure_Chain* senderchain_;
  ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain > receiverchains_;
  ::textsecure::SessionStructure_PendingKeyExchange* pendingkeyexchange_;
  ::textsecure::SessionStructure_PendingPreKey* pendingprekey_;
  ::google::protobuf::uint32 remoteregistrationid_;
  ::google::protobuf::uint32 localregistrationid_;
  ::std::string* alicebasekey_;
  bool needsrefresh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SessionStructure* default_instance_;
};
// -------------------------------------------------------------------

class RecordStructure : public ::google::protobuf::Message {
 public:
  RecordStructure();
  virtual ~RecordStructure();

  RecordStructure(const RecordStructure& from);

  inline RecordStructure& operator=(const RecordStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordStructure& default_instance();

  void Swap(RecordStructure* other);

  // implements Message ----------------------------------------------

  RecordStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordStructure& from);
  void MergeFrom(const RecordStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .textsecure.SessionStructure currentSession = 1;
  inline bool has_currentsession() const;
  inline void clear_currentsession();
  static const int kCurrentSessionFieldNumber = 1;
  inline const ::textsecure::SessionStructure& currentsession() const;
  inline ::textsecure::SessionStructure* mutable_currentsession();
  inline ::textsecure::SessionStructure* release_currentsession();
  inline void set_allocated_currentsession(::textsecure::SessionStructure* currentsession);

  // repeated .textsecure.SessionStructure previousSessions = 2;
  inline int previoussessions_size() const;
  inline void clear_previoussessions();
  static const int kPreviousSessionsFieldNumber = 2;
  inline const ::textsecure::SessionStructure& previoussessions(int index) const;
  inline ::textsecure::SessionStructure* mutable_previoussessions(int index);
  inline ::textsecure::SessionStructure* add_previoussessions();
  inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure >&
      previoussessions() const;
  inline ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure >*
      mutable_previoussessions();

  // @@protoc_insertion_point(class_scope:textsecure.RecordStructure)
 private:
  inline void set_has_currentsession();
  inline void clear_has_currentsession();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::textsecure::SessionStructure* currentsession_;
  ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure > previoussessions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static RecordStructure* default_instance_;
};
// -------------------------------------------------------------------

class PreKeyRecordStructure : public ::google::protobuf::Message {
 public:
  PreKeyRecordStructure();
  virtual ~PreKeyRecordStructure();

  PreKeyRecordStructure(const PreKeyRecordStructure& from);

  inline PreKeyRecordStructure& operator=(const PreKeyRecordStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreKeyRecordStructure& default_instance();

  void Swap(PreKeyRecordStructure* other);

  // implements Message ----------------------------------------------

  PreKeyRecordStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreKeyRecordStructure& from);
  void MergeFrom(const PreKeyRecordStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bytes publicKey = 2;
  inline bool has_publickey() const;
  inline void clear_publickey();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& publickey() const;
  inline void set_publickey(const ::std::string& value);
  inline void set_publickey(const char* value);
  inline void set_publickey(const void* value, size_t size);
  inline ::std::string* mutable_publickey();
  inline ::std::string* release_publickey();
  inline void set_allocated_publickey(::std::string* publickey);

  // optional bytes privateKey = 3;
  inline bool has_privatekey() const;
  inline void clear_privatekey();
  static const int kPrivateKeyFieldNumber = 3;
  inline const ::std::string& privatekey() const;
  inline void set_privatekey(const ::std::string& value);
  inline void set_privatekey(const char* value);
  inline void set_privatekey(const void* value, size_t size);
  inline ::std::string* mutable_privatekey();
  inline ::std::string* release_privatekey();
  inline void set_allocated_privatekey(::std::string* privatekey);

  // @@protoc_insertion_point(class_scope:textsecure.PreKeyRecordStructure)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_publickey();
  inline void clear_has_publickey();
  inline void set_has_privatekey();
  inline void clear_has_privatekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publickey_;
  ::std::string* privatekey_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static PreKeyRecordStructure* default_instance_;
};
// -------------------------------------------------------------------

class SignedPreKeyRecordStructure : public ::google::protobuf::Message {
 public:
  SignedPreKeyRecordStructure();
  virtual ~SignedPreKeyRecordStructure();

  SignedPreKeyRecordStructure(const SignedPreKeyRecordStructure& from);

  inline SignedPreKeyRecordStructure& operator=(const SignedPreKeyRecordStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedPreKeyRecordStructure& default_instance();

  void Swap(SignedPreKeyRecordStructure* other);

  // implements Message ----------------------------------------------

  SignedPreKeyRecordStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedPreKeyRecordStructure& from);
  void MergeFrom(const SignedPreKeyRecordStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bytes publicKey = 2;
  inline bool has_publickey() const;
  inline void clear_publickey();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& publickey() const;
  inline void set_publickey(const ::std::string& value);
  inline void set_publickey(const char* value);
  inline void set_publickey(const void* value, size_t size);
  inline ::std::string* mutable_publickey();
  inline ::std::string* release_publickey();
  inline void set_allocated_publickey(::std::string* publickey);

  // optional bytes privateKey = 3;
  inline bool has_privatekey() const;
  inline void clear_privatekey();
  static const int kPrivateKeyFieldNumber = 3;
  inline const ::std::string& privatekey() const;
  inline void set_privatekey(const ::std::string& value);
  inline void set_privatekey(const char* value);
  inline void set_privatekey(const void* value, size_t size);
  inline ::std::string* mutable_privatekey();
  inline ::std::string* release_privatekey();
  inline void set_allocated_privatekey(::std::string* privatekey);

  // optional bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional fixed64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:textsecure.SignedPreKeyRecordStructure)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_publickey();
  inline void clear_has_publickey();
  inline void set_has_privatekey();
  inline void clear_has_privatekey();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publickey_;
  ::std::string* privatekey_;
  ::std::string* signature_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SignedPreKeyRecordStructure* default_instance_;
};
// -------------------------------------------------------------------

class IdentityKeyPairStructure : public ::google::protobuf::Message {
 public:
  IdentityKeyPairStructure();
  virtual ~IdentityKeyPairStructure();

  IdentityKeyPairStructure(const IdentityKeyPairStructure& from);

  inline IdentityKeyPairStructure& operator=(const IdentityKeyPairStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IdentityKeyPairStructure& default_instance();

  void Swap(IdentityKeyPairStructure* other);

  // implements Message ----------------------------------------------

  IdentityKeyPairStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IdentityKeyPairStructure& from);
  void MergeFrom(const IdentityKeyPairStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes publicKey = 1;
  inline bool has_publickey() const;
  inline void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  inline const ::std::string& publickey() const;
  inline void set_publickey(const ::std::string& value);
  inline void set_publickey(const char* value);
  inline void set_publickey(const void* value, size_t size);
  inline ::std::string* mutable_publickey();
  inline ::std::string* release_publickey();
  inline void set_allocated_publickey(::std::string* publickey);

  // optional bytes privateKey = 2;
  inline bool has_privatekey() const;
  inline void clear_privatekey();
  static const int kPrivateKeyFieldNumber = 2;
  inline const ::std::string& privatekey() const;
  inline void set_privatekey(const ::std::string& value);
  inline void set_privatekey(const char* value);
  inline void set_privatekey(const void* value, size_t size);
  inline ::std::string* mutable_privatekey();
  inline ::std::string* release_privatekey();
  inline void set_allocated_privatekey(::std::string* privatekey);

  // @@protoc_insertion_point(class_scope:textsecure.IdentityKeyPairStructure)
 private:
  inline void set_has_publickey();
  inline void clear_has_publickey();
  inline void set_has_privatekey();
  inline void clear_has_privatekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publickey_;
  ::std::string* privatekey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static IdentityKeyPairStructure* default_instance_;
};
// -------------------------------------------------------------------

class SenderKeyStateStructure_SenderChainKey : public ::google::protobuf::Message {
 public:
  SenderKeyStateStructure_SenderChainKey();
  virtual ~SenderKeyStateStructure_SenderChainKey();

  SenderKeyStateStructure_SenderChainKey(const SenderKeyStateStructure_SenderChainKey& from);

  inline SenderKeyStateStructure_SenderChainKey& operator=(const SenderKeyStateStructure_SenderChainKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SenderKeyStateStructure_SenderChainKey& default_instance();

  void Swap(SenderKeyStateStructure_SenderChainKey* other);

  // implements Message ----------------------------------------------

  SenderKeyStateStructure_SenderChainKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SenderKeyStateStructure_SenderChainKey& from);
  void MergeFrom(const SenderKeyStateStructure_SenderChainKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 iteration = 1;
  inline bool has_iteration() const;
  inline void clear_iteration();
  static const int kIterationFieldNumber = 1;
  inline ::google::protobuf::uint32 iteration() const;
  inline void set_iteration(::google::protobuf::uint32 value);

  // optional bytes seed = 2;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 2;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const void* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  inline void set_allocated_seed(::std::string* seed);

  // @@protoc_insertion_point(class_scope:textsecure.SenderKeyStateStructure.SenderChainKey)
 private:
  inline void set_has_iteration();
  inline void clear_has_iteration();
  inline void set_has_seed();
  inline void clear_has_seed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* seed_;
  ::google::protobuf::uint32 iteration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SenderKeyStateStructure_SenderChainKey* default_instance_;
};
// -------------------------------------------------------------------

class SenderKeyStateStructure_SenderMessageKey : public ::google::protobuf::Message {
 public:
  SenderKeyStateStructure_SenderMessageKey();
  virtual ~SenderKeyStateStructure_SenderMessageKey();

  SenderKeyStateStructure_SenderMessageKey(const SenderKeyStateStructure_SenderMessageKey& from);

  inline SenderKeyStateStructure_SenderMessageKey& operator=(const SenderKeyStateStructure_SenderMessageKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SenderKeyStateStructure_SenderMessageKey& default_instance();

  void Swap(SenderKeyStateStructure_SenderMessageKey* other);

  // implements Message ----------------------------------------------

  SenderKeyStateStructure_SenderMessageKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SenderKeyStateStructure_SenderMessageKey& from);
  void MergeFrom(const SenderKeyStateStructure_SenderMessageKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 iteration = 1;
  inline bool has_iteration() const;
  inline void clear_iteration();
  static const int kIterationFieldNumber = 1;
  inline ::google::protobuf::uint32 iteration() const;
  inline void set_iteration(::google::protobuf::uint32 value);

  // optional bytes seed = 2;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 2;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const void* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  inline void set_allocated_seed(::std::string* seed);

  // @@protoc_insertion_point(class_scope:textsecure.SenderKeyStateStructure.SenderMessageKey)
 private:
  inline void set_has_iteration();
  inline void clear_has_iteration();
  inline void set_has_seed();
  inline void clear_has_seed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* seed_;
  ::google::protobuf::uint32 iteration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SenderKeyStateStructure_SenderMessageKey* default_instance_;
};
// -------------------------------------------------------------------

class SenderKeyStateStructure_SenderSigningKey : public ::google::protobuf::Message {
 public:
  SenderKeyStateStructure_SenderSigningKey();
  virtual ~SenderKeyStateStructure_SenderSigningKey();

  SenderKeyStateStructure_SenderSigningKey(const SenderKeyStateStructure_SenderSigningKey& from);

  inline SenderKeyStateStructure_SenderSigningKey& operator=(const SenderKeyStateStructure_SenderSigningKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SenderKeyStateStructure_SenderSigningKey& default_instance();

  void Swap(SenderKeyStateStructure_SenderSigningKey* other);

  // implements Message ----------------------------------------------

  SenderKeyStateStructure_SenderSigningKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SenderKeyStateStructure_SenderSigningKey& from);
  void MergeFrom(const SenderKeyStateStructure_SenderSigningKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public = 1;
  inline bool has_public_() const;
  inline void clear_public_();
  static const int kPublicFieldNumber = 1;
  inline const ::std::string& public_() const;
  inline void set_public_(const ::std::string& value);
  inline void set_public_(const char* value);
  inline void set_public_(const void* value, size_t size);
  inline ::std::string* mutable_public_();
  inline ::std::string* release_public_();
  inline void set_allocated_public_(::std::string* public_);

  // optional bytes private = 2;
  inline bool has_private_() const;
  inline void clear_private_();
  static const int kPrivateFieldNumber = 2;
  inline const ::std::string& private_() const;
  inline void set_private_(const ::std::string& value);
  inline void set_private_(const char* value);
  inline void set_private_(const void* value, size_t size);
  inline ::std::string* mutable_private_();
  inline ::std::string* release_private_();
  inline void set_allocated_private_(::std::string* private_);

  // @@protoc_insertion_point(class_scope:textsecure.SenderKeyStateStructure.SenderSigningKey)
 private:
  inline void set_has_public_();
  inline void clear_has_public_();
  inline void set_has_private_();
  inline void clear_has_private_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* public__;
  ::std::string* private__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SenderKeyStateStructure_SenderSigningKey* default_instance_;
};
// -------------------------------------------------------------------

class SenderKeyStateStructure : public ::google::protobuf::Message {
 public:
  SenderKeyStateStructure();
  virtual ~SenderKeyStateStructure();

  SenderKeyStateStructure(const SenderKeyStateStructure& from);

  inline SenderKeyStateStructure& operator=(const SenderKeyStateStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SenderKeyStateStructure& default_instance();

  void Swap(SenderKeyStateStructure* other);

  // implements Message ----------------------------------------------

  SenderKeyStateStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SenderKeyStateStructure& from);
  void MergeFrom(const SenderKeyStateStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SenderKeyStateStructure_SenderChainKey SenderChainKey;
  typedef SenderKeyStateStructure_SenderMessageKey SenderMessageKey;
  typedef SenderKeyStateStructure_SenderSigningKey SenderSigningKey;

  // accessors -------------------------------------------------------

  // optional uint32 senderKeyId = 1;
  inline bool has_senderkeyid() const;
  inline void clear_senderkeyid();
  static const int kSenderKeyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 senderkeyid() const;
  inline void set_senderkeyid(::google::protobuf::uint32 value);

  // optional .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKey = 2;
  inline bool has_senderchainkey() const;
  inline void clear_senderchainkey();
  static const int kSenderChainKeyFieldNumber = 2;
  inline const ::textsecure::SenderKeyStateStructure_SenderChainKey& senderchainkey() const;
  inline ::textsecure::SenderKeyStateStructure_SenderChainKey* mutable_senderchainkey();
  inline ::textsecure::SenderKeyStateStructure_SenderChainKey* release_senderchainkey();
  inline void set_allocated_senderchainkey(::textsecure::SenderKeyStateStructure_SenderChainKey* senderchainkey);

  // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
  inline bool has_sendersigningkey() const;
  inline void clear_sendersigningkey();
  static const int kSenderSigningKeyFieldNumber = 3;
  inline const ::textsecure::SenderKeyStateStructure_SenderSigningKey& sendersigningkey() const;
  inline ::textsecure::SenderKeyStateStructure_SenderSigningKey* mutable_sendersigningkey();
  inline ::textsecure::SenderKeyStateStructure_SenderSigningKey* release_sendersigningkey();
  inline void set_allocated_sendersigningkey(::textsecure::SenderKeyStateStructure_SenderSigningKey* sendersigningkey);

  // repeated .textsecure.SenderKeyStateStructure.SenderMessageKey senderMessageKeys = 4;
  inline int sendermessagekeys_size() const;
  inline void clear_sendermessagekeys();
  static const int kSenderMessageKeysFieldNumber = 4;
  inline const ::textsecure::SenderKeyStateStructure_SenderMessageKey& sendermessagekeys(int index) const;
  inline ::textsecure::SenderKeyStateStructure_SenderMessageKey* mutable_sendermessagekeys(int index);
  inline ::textsecure::SenderKeyStateStructure_SenderMessageKey* add_sendermessagekeys();
  inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure_SenderMessageKey >&
      sendermessagekeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure_SenderMessageKey >*
      mutable_sendermessagekeys();

  // @@protoc_insertion_point(class_scope:textsecure.SenderKeyStateStructure)
 private:
  inline void set_has_senderkeyid();
  inline void clear_has_senderkeyid();
  inline void set_has_senderchainkey();
  inline void clear_has_senderchainkey();
  inline void set_has_sendersigningkey();
  inline void clear_has_sendersigningkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::textsecure::SenderKeyStateStructure_SenderChainKey* senderchainkey_;
  ::textsecure::SenderKeyStateStructure_SenderSigningKey* sendersigningkey_;
  ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure_SenderMessageKey > sendermessagekeys_;
  ::google::protobuf::uint32 senderkeyid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SenderKeyStateStructure* default_instance_;
};
// -------------------------------------------------------------------

class SenderKeyRecordStructure : public ::google::protobuf::Message {
 public:
  SenderKeyRecordStructure();
  virtual ~SenderKeyRecordStructure();

  SenderKeyRecordStructure(const SenderKeyRecordStructure& from);

  inline SenderKeyRecordStructure& operator=(const SenderKeyRecordStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SenderKeyRecordStructure& default_instance();

  void Swap(SenderKeyRecordStructure* other);

  // implements Message ----------------------------------------------

  SenderKeyRecordStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SenderKeyRecordStructure& from);
  void MergeFrom(const SenderKeyRecordStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .textsecure.SenderKeyStateStructure senderKeyStates = 1;
  inline int senderkeystates_size() const;
  inline void clear_senderkeystates();
  static const int kSenderKeyStatesFieldNumber = 1;
  inline const ::textsecure::SenderKeyStateStructure& senderkeystates(int index) const;
  inline ::textsecure::SenderKeyStateStructure* mutable_senderkeystates(int index);
  inline ::textsecure::SenderKeyStateStructure* add_senderkeystates();
  inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure >&
      senderkeystates() const;
  inline ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure >*
      mutable_senderkeystates();

  // @@protoc_insertion_point(class_scope:textsecure.SenderKeyRecordStructure)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure > senderkeystates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto();
  friend void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto();

  void InitAsDefaultInstance();
  static SenderKeyRecordStructure* default_instance_;
};
// ===================================================================


// ===================================================================

// SessionStructure_Chain_ChainKey

// optional uint32 index = 1;
inline bool SessionStructure_Chain_ChainKey::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStructure_Chain_ChainKey::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStructure_Chain_ChainKey::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStructure_Chain_ChainKey::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SessionStructure_Chain_ChainKey::index() const {
  return index_;
}
inline void SessionStructure_Chain_ChainKey::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional bytes key = 2;
inline bool SessionStructure_Chain_ChainKey::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStructure_Chain_ChainKey::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStructure_Chain_ChainKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStructure_Chain_ChainKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& SessionStructure_Chain_ChainKey::key() const {
  return *key_;
}
inline void SessionStructure_Chain_ChainKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SessionStructure_Chain_ChainKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SessionStructure_Chain_ChainKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_Chain_ChainKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* SessionStructure_Chain_ChainKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_Chain_ChainKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SessionStructure_Chain_MessageKey

// optional uint32 index = 1;
inline bool SessionStructure_Chain_MessageKey::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStructure_Chain_MessageKey::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStructure_Chain_MessageKey::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStructure_Chain_MessageKey::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SessionStructure_Chain_MessageKey::index() const {
  return index_;
}
inline void SessionStructure_Chain_MessageKey::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional bytes cipherKey = 2;
inline bool SessionStructure_Chain_MessageKey::has_cipherkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStructure_Chain_MessageKey::set_has_cipherkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStructure_Chain_MessageKey::clear_has_cipherkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStructure_Chain_MessageKey::clear_cipherkey() {
  if (cipherkey_ != &::google::protobuf::internal::kEmptyString) {
    cipherkey_->clear();
  }
  clear_has_cipherkey();
}
inline const ::std::string& SessionStructure_Chain_MessageKey::cipherkey() const {
  return *cipherkey_;
}
inline void SessionStructure_Chain_MessageKey::set_cipherkey(const ::std::string& value) {
  set_has_cipherkey();
  if (cipherkey_ == &::google::protobuf::internal::kEmptyString) {
    cipherkey_ = new ::std::string;
  }
  cipherkey_->assign(value);
}
inline void SessionStructure_Chain_MessageKey::set_cipherkey(const char* value) {
  set_has_cipherkey();
  if (cipherkey_ == &::google::protobuf::internal::kEmptyString) {
    cipherkey_ = new ::std::string;
  }
  cipherkey_->assign(value);
}
inline void SessionStructure_Chain_MessageKey::set_cipherkey(const void* value, size_t size) {
  set_has_cipherkey();
  if (cipherkey_ == &::google::protobuf::internal::kEmptyString) {
    cipherkey_ = new ::std::string;
  }
  cipherkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_Chain_MessageKey::mutable_cipherkey() {
  set_has_cipherkey();
  if (cipherkey_ == &::google::protobuf::internal::kEmptyString) {
    cipherkey_ = new ::std::string;
  }
  return cipherkey_;
}
inline ::std::string* SessionStructure_Chain_MessageKey::release_cipherkey() {
  clear_has_cipherkey();
  if (cipherkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cipherkey_;
    cipherkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_Chain_MessageKey::set_allocated_cipherkey(::std::string* cipherkey) {
  if (cipherkey_ != &::google::protobuf::internal::kEmptyString) {
    delete cipherkey_;
  }
  if (cipherkey) {
    set_has_cipherkey();
    cipherkey_ = cipherkey;
  } else {
    clear_has_cipherkey();
    cipherkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes macKey = 3;
inline bool SessionStructure_Chain_MessageKey::has_mackey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionStructure_Chain_MessageKey::set_has_mackey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionStructure_Chain_MessageKey::clear_has_mackey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionStructure_Chain_MessageKey::clear_mackey() {
  if (mackey_ != &::google::protobuf::internal::kEmptyString) {
    mackey_->clear();
  }
  clear_has_mackey();
}
inline const ::std::string& SessionStructure_Chain_MessageKey::mackey() const {
  return *mackey_;
}
inline void SessionStructure_Chain_MessageKey::set_mackey(const ::std::string& value) {
  set_has_mackey();
  if (mackey_ == &::google::protobuf::internal::kEmptyString) {
    mackey_ = new ::std::string;
  }
  mackey_->assign(value);
}
inline void SessionStructure_Chain_MessageKey::set_mackey(const char* value) {
  set_has_mackey();
  if (mackey_ == &::google::protobuf::internal::kEmptyString) {
    mackey_ = new ::std::string;
  }
  mackey_->assign(value);
}
inline void SessionStructure_Chain_MessageKey::set_mackey(const void* value, size_t size) {
  set_has_mackey();
  if (mackey_ == &::google::protobuf::internal::kEmptyString) {
    mackey_ = new ::std::string;
  }
  mackey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_Chain_MessageKey::mutable_mackey() {
  set_has_mackey();
  if (mackey_ == &::google::protobuf::internal::kEmptyString) {
    mackey_ = new ::std::string;
  }
  return mackey_;
}
inline ::std::string* SessionStructure_Chain_MessageKey::release_mackey() {
  clear_has_mackey();
  if (mackey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mackey_;
    mackey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_Chain_MessageKey::set_allocated_mackey(::std::string* mackey) {
  if (mackey_ != &::google::protobuf::internal::kEmptyString) {
    delete mackey_;
  }
  if (mackey) {
    set_has_mackey();
    mackey_ = mackey;
  } else {
    clear_has_mackey();
    mackey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes iv = 4;
inline bool SessionStructure_Chain_MessageKey::has_iv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionStructure_Chain_MessageKey::set_has_iv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionStructure_Chain_MessageKey::clear_has_iv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionStructure_Chain_MessageKey::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& SessionStructure_Chain_MessageKey::iv() const {
  return *iv_;
}
inline void SessionStructure_Chain_MessageKey::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void SessionStructure_Chain_MessageKey::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void SessionStructure_Chain_MessageKey::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_Chain_MessageKey::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* SessionStructure_Chain_MessageKey::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_Chain_MessageKey::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SessionStructure_Chain

// optional bytes senderRatchetKey = 1;
inline bool SessionStructure_Chain::has_senderratchetkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStructure_Chain::set_has_senderratchetkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStructure_Chain::clear_has_senderratchetkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStructure_Chain::clear_senderratchetkey() {
  if (senderratchetkey_ != &::google::protobuf::internal::kEmptyString) {
    senderratchetkey_->clear();
  }
  clear_has_senderratchetkey();
}
inline const ::std::string& SessionStructure_Chain::senderratchetkey() const {
  return *senderratchetkey_;
}
inline void SessionStructure_Chain::set_senderratchetkey(const ::std::string& value) {
  set_has_senderratchetkey();
  if (senderratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkey_ = new ::std::string;
  }
  senderratchetkey_->assign(value);
}
inline void SessionStructure_Chain::set_senderratchetkey(const char* value) {
  set_has_senderratchetkey();
  if (senderratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkey_ = new ::std::string;
  }
  senderratchetkey_->assign(value);
}
inline void SessionStructure_Chain::set_senderratchetkey(const void* value, size_t size) {
  set_has_senderratchetkey();
  if (senderratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkey_ = new ::std::string;
  }
  senderratchetkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_Chain::mutable_senderratchetkey() {
  set_has_senderratchetkey();
  if (senderratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkey_ = new ::std::string;
  }
  return senderratchetkey_;
}
inline ::std::string* SessionStructure_Chain::release_senderratchetkey() {
  clear_has_senderratchetkey();
  if (senderratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = senderratchetkey_;
    senderratchetkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_Chain::set_allocated_senderratchetkey(::std::string* senderratchetkey) {
  if (senderratchetkey_ != &::google::protobuf::internal::kEmptyString) {
    delete senderratchetkey_;
  }
  if (senderratchetkey) {
    set_has_senderratchetkey();
    senderratchetkey_ = senderratchetkey;
  } else {
    clear_has_senderratchetkey();
    senderratchetkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes senderRatchetKeyPrivate = 2;
inline bool SessionStructure_Chain::has_senderratchetkeyprivate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStructure_Chain::set_has_senderratchetkeyprivate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStructure_Chain::clear_has_senderratchetkeyprivate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStructure_Chain::clear_senderratchetkeyprivate() {
  if (senderratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    senderratchetkeyprivate_->clear();
  }
  clear_has_senderratchetkeyprivate();
}
inline const ::std::string& SessionStructure_Chain::senderratchetkeyprivate() const {
  return *senderratchetkeyprivate_;
}
inline void SessionStructure_Chain::set_senderratchetkeyprivate(const ::std::string& value) {
  set_has_senderratchetkeyprivate();
  if (senderratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkeyprivate_ = new ::std::string;
  }
  senderratchetkeyprivate_->assign(value);
}
inline void SessionStructure_Chain::set_senderratchetkeyprivate(const char* value) {
  set_has_senderratchetkeyprivate();
  if (senderratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkeyprivate_ = new ::std::string;
  }
  senderratchetkeyprivate_->assign(value);
}
inline void SessionStructure_Chain::set_senderratchetkeyprivate(const void* value, size_t size) {
  set_has_senderratchetkeyprivate();
  if (senderratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkeyprivate_ = new ::std::string;
  }
  senderratchetkeyprivate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_Chain::mutable_senderratchetkeyprivate() {
  set_has_senderratchetkeyprivate();
  if (senderratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    senderratchetkeyprivate_ = new ::std::string;
  }
  return senderratchetkeyprivate_;
}
inline ::std::string* SessionStructure_Chain::release_senderratchetkeyprivate() {
  clear_has_senderratchetkeyprivate();
  if (senderratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = senderratchetkeyprivate_;
    senderratchetkeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_Chain::set_allocated_senderratchetkeyprivate(::std::string* senderratchetkeyprivate) {
  if (senderratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete senderratchetkeyprivate_;
  }
  if (senderratchetkeyprivate) {
    set_has_senderratchetkeyprivate();
    senderratchetkeyprivate_ = senderratchetkeyprivate;
  } else {
    clear_has_senderratchetkeyprivate();
    senderratchetkeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .textsecure.SessionStructure.Chain.ChainKey chainKey = 3;
inline bool SessionStructure_Chain::has_chainkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionStructure_Chain::set_has_chainkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionStructure_Chain::clear_has_chainkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionStructure_Chain::clear_chainkey() {
  if (chainkey_ != NULL) chainkey_->::textsecure::SessionStructure_Chain_ChainKey::Clear();
  clear_has_chainkey();
}
inline const ::textsecure::SessionStructure_Chain_ChainKey& SessionStructure_Chain::chainkey() const {
  return chainkey_ != NULL ? *chainkey_ : *default_instance_->chainkey_;
}
inline ::textsecure::SessionStructure_Chain_ChainKey* SessionStructure_Chain::mutable_chainkey() {
  set_has_chainkey();
  if (chainkey_ == NULL) chainkey_ = new ::textsecure::SessionStructure_Chain_ChainKey;
  return chainkey_;
}
inline ::textsecure::SessionStructure_Chain_ChainKey* SessionStructure_Chain::release_chainkey() {
  clear_has_chainkey();
  ::textsecure::SessionStructure_Chain_ChainKey* temp = chainkey_;
  chainkey_ = NULL;
  return temp;
}
inline void SessionStructure_Chain::set_allocated_chainkey(::textsecure::SessionStructure_Chain_ChainKey* chainkey) {
  delete chainkey_;
  chainkey_ = chainkey;
  if (chainkey) {
    set_has_chainkey();
  } else {
    clear_has_chainkey();
  }
}

// repeated .textsecure.SessionStructure.Chain.MessageKey messageKeys = 4;
inline int SessionStructure_Chain::messagekeys_size() const {
  return messagekeys_.size();
}
inline void SessionStructure_Chain::clear_messagekeys() {
  messagekeys_.Clear();
}
inline const ::textsecure::SessionStructure_Chain_MessageKey& SessionStructure_Chain::messagekeys(int index) const {
  return messagekeys_.Get(index);
}
inline ::textsecure::SessionStructure_Chain_MessageKey* SessionStructure_Chain::mutable_messagekeys(int index) {
  return messagekeys_.Mutable(index);
}
inline ::textsecure::SessionStructure_Chain_MessageKey* SessionStructure_Chain::add_messagekeys() {
  return messagekeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain_MessageKey >&
SessionStructure_Chain::messagekeys() const {
  return messagekeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain_MessageKey >*
SessionStructure_Chain::mutable_messagekeys() {
  return &messagekeys_;
}

// -------------------------------------------------------------------

// SessionStructure_PendingKeyExchange

// optional uint32 sequence = 1;
inline bool SessionStructure_PendingKeyExchange::has_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStructure_PendingKeyExchange::set_has_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStructure_PendingKeyExchange::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStructure_PendingKeyExchange::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 SessionStructure_PendingKeyExchange::sequence() const {
  return sequence_;
}
inline void SessionStructure_PendingKeyExchange::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional bytes localBaseKey = 2;
inline bool SessionStructure_PendingKeyExchange::has_localbasekey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStructure_PendingKeyExchange::set_has_localbasekey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStructure_PendingKeyExchange::clear_has_localbasekey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStructure_PendingKeyExchange::clear_localbasekey() {
  if (localbasekey_ != &::google::protobuf::internal::kEmptyString) {
    localbasekey_->clear();
  }
  clear_has_localbasekey();
}
inline const ::std::string& SessionStructure_PendingKeyExchange::localbasekey() const {
  return *localbasekey_;
}
inline void SessionStructure_PendingKeyExchange::set_localbasekey(const ::std::string& value) {
  set_has_localbasekey();
  if (localbasekey_ == &::google::protobuf::internal::kEmptyString) {
    localbasekey_ = new ::std::string;
  }
  localbasekey_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localbasekey(const char* value) {
  set_has_localbasekey();
  if (localbasekey_ == &::google::protobuf::internal::kEmptyString) {
    localbasekey_ = new ::std::string;
  }
  localbasekey_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localbasekey(const void* value, size_t size) {
  set_has_localbasekey();
  if (localbasekey_ == &::google::protobuf::internal::kEmptyString) {
    localbasekey_ = new ::std::string;
  }
  localbasekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_PendingKeyExchange::mutable_localbasekey() {
  set_has_localbasekey();
  if (localbasekey_ == &::google::protobuf::internal::kEmptyString) {
    localbasekey_ = new ::std::string;
  }
  return localbasekey_;
}
inline ::std::string* SessionStructure_PendingKeyExchange::release_localbasekey() {
  clear_has_localbasekey();
  if (localbasekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localbasekey_;
    localbasekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_PendingKeyExchange::set_allocated_localbasekey(::std::string* localbasekey) {
  if (localbasekey_ != &::google::protobuf::internal::kEmptyString) {
    delete localbasekey_;
  }
  if (localbasekey) {
    set_has_localbasekey();
    localbasekey_ = localbasekey;
  } else {
    clear_has_localbasekey();
    localbasekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes localBaseKeyPrivate = 3;
inline bool SessionStructure_PendingKeyExchange::has_localbasekeyprivate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionStructure_PendingKeyExchange::set_has_localbasekeyprivate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionStructure_PendingKeyExchange::clear_has_localbasekeyprivate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionStructure_PendingKeyExchange::clear_localbasekeyprivate() {
  if (localbasekeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    localbasekeyprivate_->clear();
  }
  clear_has_localbasekeyprivate();
}
inline const ::std::string& SessionStructure_PendingKeyExchange::localbasekeyprivate() const {
  return *localbasekeyprivate_;
}
inline void SessionStructure_PendingKeyExchange::set_localbasekeyprivate(const ::std::string& value) {
  set_has_localbasekeyprivate();
  if (localbasekeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localbasekeyprivate_ = new ::std::string;
  }
  localbasekeyprivate_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localbasekeyprivate(const char* value) {
  set_has_localbasekeyprivate();
  if (localbasekeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localbasekeyprivate_ = new ::std::string;
  }
  localbasekeyprivate_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localbasekeyprivate(const void* value, size_t size) {
  set_has_localbasekeyprivate();
  if (localbasekeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localbasekeyprivate_ = new ::std::string;
  }
  localbasekeyprivate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_PendingKeyExchange::mutable_localbasekeyprivate() {
  set_has_localbasekeyprivate();
  if (localbasekeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localbasekeyprivate_ = new ::std::string;
  }
  return localbasekeyprivate_;
}
inline ::std::string* SessionStructure_PendingKeyExchange::release_localbasekeyprivate() {
  clear_has_localbasekeyprivate();
  if (localbasekeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localbasekeyprivate_;
    localbasekeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_PendingKeyExchange::set_allocated_localbasekeyprivate(::std::string* localbasekeyprivate) {
  if (localbasekeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete localbasekeyprivate_;
  }
  if (localbasekeyprivate) {
    set_has_localbasekeyprivate();
    localbasekeyprivate_ = localbasekeyprivate;
  } else {
    clear_has_localbasekeyprivate();
    localbasekeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes localRatchetKey = 4;
inline bool SessionStructure_PendingKeyExchange::has_localratchetkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionStructure_PendingKeyExchange::set_has_localratchetkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionStructure_PendingKeyExchange::clear_has_localratchetkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionStructure_PendingKeyExchange::clear_localratchetkey() {
  if (localratchetkey_ != &::google::protobuf::internal::kEmptyString) {
    localratchetkey_->clear();
  }
  clear_has_localratchetkey();
}
inline const ::std::string& SessionStructure_PendingKeyExchange::localratchetkey() const {
  return *localratchetkey_;
}
inline void SessionStructure_PendingKeyExchange::set_localratchetkey(const ::std::string& value) {
  set_has_localratchetkey();
  if (localratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkey_ = new ::std::string;
  }
  localratchetkey_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localratchetkey(const char* value) {
  set_has_localratchetkey();
  if (localratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkey_ = new ::std::string;
  }
  localratchetkey_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localratchetkey(const void* value, size_t size) {
  set_has_localratchetkey();
  if (localratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkey_ = new ::std::string;
  }
  localratchetkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_PendingKeyExchange::mutable_localratchetkey() {
  set_has_localratchetkey();
  if (localratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkey_ = new ::std::string;
  }
  return localratchetkey_;
}
inline ::std::string* SessionStructure_PendingKeyExchange::release_localratchetkey() {
  clear_has_localratchetkey();
  if (localratchetkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localratchetkey_;
    localratchetkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_PendingKeyExchange::set_allocated_localratchetkey(::std::string* localratchetkey) {
  if (localratchetkey_ != &::google::protobuf::internal::kEmptyString) {
    delete localratchetkey_;
  }
  if (localratchetkey) {
    set_has_localratchetkey();
    localratchetkey_ = localratchetkey;
  } else {
    clear_has_localratchetkey();
    localratchetkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes localRatchetKeyPrivate = 5;
inline bool SessionStructure_PendingKeyExchange::has_localratchetkeyprivate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionStructure_PendingKeyExchange::set_has_localratchetkeyprivate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionStructure_PendingKeyExchange::clear_has_localratchetkeyprivate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionStructure_PendingKeyExchange::clear_localratchetkeyprivate() {
  if (localratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    localratchetkeyprivate_->clear();
  }
  clear_has_localratchetkeyprivate();
}
inline const ::std::string& SessionStructure_PendingKeyExchange::localratchetkeyprivate() const {
  return *localratchetkeyprivate_;
}
inline void SessionStructure_PendingKeyExchange::set_localratchetkeyprivate(const ::std::string& value) {
  set_has_localratchetkeyprivate();
  if (localratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkeyprivate_ = new ::std::string;
  }
  localratchetkeyprivate_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localratchetkeyprivate(const char* value) {
  set_has_localratchetkeyprivate();
  if (localratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkeyprivate_ = new ::std::string;
  }
  localratchetkeyprivate_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localratchetkeyprivate(const void* value, size_t size) {
  set_has_localratchetkeyprivate();
  if (localratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkeyprivate_ = new ::std::string;
  }
  localratchetkeyprivate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_PendingKeyExchange::mutable_localratchetkeyprivate() {
  set_has_localratchetkeyprivate();
  if (localratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localratchetkeyprivate_ = new ::std::string;
  }
  return localratchetkeyprivate_;
}
inline ::std::string* SessionStructure_PendingKeyExchange::release_localratchetkeyprivate() {
  clear_has_localratchetkeyprivate();
  if (localratchetkeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localratchetkeyprivate_;
    localratchetkeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_PendingKeyExchange::set_allocated_localratchetkeyprivate(::std::string* localratchetkeyprivate) {
  if (localratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete localratchetkeyprivate_;
  }
  if (localratchetkeyprivate) {
    set_has_localratchetkeyprivate();
    localratchetkeyprivate_ = localratchetkeyprivate;
  } else {
    clear_has_localratchetkeyprivate();
    localratchetkeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes localIdentityKey = 7;
inline bool SessionStructure_PendingKeyExchange::has_localidentitykey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SessionStructure_PendingKeyExchange::set_has_localidentitykey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SessionStructure_PendingKeyExchange::clear_has_localidentitykey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SessionStructure_PendingKeyExchange::clear_localidentitykey() {
  if (localidentitykey_ != &::google::protobuf::internal::kEmptyString) {
    localidentitykey_->clear();
  }
  clear_has_localidentitykey();
}
inline const ::std::string& SessionStructure_PendingKeyExchange::localidentitykey() const {
  return *localidentitykey_;
}
inline void SessionStructure_PendingKeyExchange::set_localidentitykey(const ::std::string& value) {
  set_has_localidentitykey();
  if (localidentitykey_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykey_ = new ::std::string;
  }
  localidentitykey_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localidentitykey(const char* value) {
  set_has_localidentitykey();
  if (localidentitykey_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykey_ = new ::std::string;
  }
  localidentitykey_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localidentitykey(const void* value, size_t size) {
  set_has_localidentitykey();
  if (localidentitykey_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykey_ = new ::std::string;
  }
  localidentitykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_PendingKeyExchange::mutable_localidentitykey() {
  set_has_localidentitykey();
  if (localidentitykey_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykey_ = new ::std::string;
  }
  return localidentitykey_;
}
inline ::std::string* SessionStructure_PendingKeyExchange::release_localidentitykey() {
  clear_has_localidentitykey();
  if (localidentitykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localidentitykey_;
    localidentitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_PendingKeyExchange::set_allocated_localidentitykey(::std::string* localidentitykey) {
  if (localidentitykey_ != &::google::protobuf::internal::kEmptyString) {
    delete localidentitykey_;
  }
  if (localidentitykey) {
    set_has_localidentitykey();
    localidentitykey_ = localidentitykey;
  } else {
    clear_has_localidentitykey();
    localidentitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes localIdentityKeyPrivate = 8;
inline bool SessionStructure_PendingKeyExchange::has_localidentitykeyprivate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SessionStructure_PendingKeyExchange::set_has_localidentitykeyprivate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SessionStructure_PendingKeyExchange::clear_has_localidentitykeyprivate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SessionStructure_PendingKeyExchange::clear_localidentitykeyprivate() {
  if (localidentitykeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    localidentitykeyprivate_->clear();
  }
  clear_has_localidentitykeyprivate();
}
inline const ::std::string& SessionStructure_PendingKeyExchange::localidentitykeyprivate() const {
  return *localidentitykeyprivate_;
}
inline void SessionStructure_PendingKeyExchange::set_localidentitykeyprivate(const ::std::string& value) {
  set_has_localidentitykeyprivate();
  if (localidentitykeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykeyprivate_ = new ::std::string;
  }
  localidentitykeyprivate_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localidentitykeyprivate(const char* value) {
  set_has_localidentitykeyprivate();
  if (localidentitykeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykeyprivate_ = new ::std::string;
  }
  localidentitykeyprivate_->assign(value);
}
inline void SessionStructure_PendingKeyExchange::set_localidentitykeyprivate(const void* value, size_t size) {
  set_has_localidentitykeyprivate();
  if (localidentitykeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykeyprivate_ = new ::std::string;
  }
  localidentitykeyprivate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_PendingKeyExchange::mutable_localidentitykeyprivate() {
  set_has_localidentitykeyprivate();
  if (localidentitykeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    localidentitykeyprivate_ = new ::std::string;
  }
  return localidentitykeyprivate_;
}
inline ::std::string* SessionStructure_PendingKeyExchange::release_localidentitykeyprivate() {
  clear_has_localidentitykeyprivate();
  if (localidentitykeyprivate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localidentitykeyprivate_;
    localidentitykeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_PendingKeyExchange::set_allocated_localidentitykeyprivate(::std::string* localidentitykeyprivate) {
  if (localidentitykeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete localidentitykeyprivate_;
  }
  if (localidentitykeyprivate) {
    set_has_localidentitykeyprivate();
    localidentitykeyprivate_ = localidentitykeyprivate;
  } else {
    clear_has_localidentitykeyprivate();
    localidentitykeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SessionStructure_PendingPreKey

// optional uint32 preKeyId = 1;
inline bool SessionStructure_PendingPreKey::has_prekeyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStructure_PendingPreKey::set_has_prekeyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStructure_PendingPreKey::clear_has_prekeyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStructure_PendingPreKey::clear_prekeyid() {
  prekeyid_ = 0u;
  clear_has_prekeyid();
}
inline ::google::protobuf::uint32 SessionStructure_PendingPreKey::prekeyid() const {
  return prekeyid_;
}
inline void SessionStructure_PendingPreKey::set_prekeyid(::google::protobuf::uint32 value) {
  set_has_prekeyid();
  prekeyid_ = value;
}

// optional int32 signedPreKeyId = 3;
inline bool SessionStructure_PendingPreKey::has_signedprekeyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStructure_PendingPreKey::set_has_signedprekeyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStructure_PendingPreKey::clear_has_signedprekeyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStructure_PendingPreKey::clear_signedprekeyid() {
  signedprekeyid_ = 0;
  clear_has_signedprekeyid();
}
inline ::google::protobuf::int32 SessionStructure_PendingPreKey::signedprekeyid() const {
  return signedprekeyid_;
}
inline void SessionStructure_PendingPreKey::set_signedprekeyid(::google::protobuf::int32 value) {
  set_has_signedprekeyid();
  signedprekeyid_ = value;
}

// optional bytes baseKey = 2;
inline bool SessionStructure_PendingPreKey::has_basekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionStructure_PendingPreKey::set_has_basekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionStructure_PendingPreKey::clear_has_basekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionStructure_PendingPreKey::clear_basekey() {
  if (basekey_ != &::google::protobuf::internal::kEmptyString) {
    basekey_->clear();
  }
  clear_has_basekey();
}
inline const ::std::string& SessionStructure_PendingPreKey::basekey() const {
  return *basekey_;
}
inline void SessionStructure_PendingPreKey::set_basekey(const ::std::string& value) {
  set_has_basekey();
  if (basekey_ == &::google::protobuf::internal::kEmptyString) {
    basekey_ = new ::std::string;
  }
  basekey_->assign(value);
}
inline void SessionStructure_PendingPreKey::set_basekey(const char* value) {
  set_has_basekey();
  if (basekey_ == &::google::protobuf::internal::kEmptyString) {
    basekey_ = new ::std::string;
  }
  basekey_->assign(value);
}
inline void SessionStructure_PendingPreKey::set_basekey(const void* value, size_t size) {
  set_has_basekey();
  if (basekey_ == &::google::protobuf::internal::kEmptyString) {
    basekey_ = new ::std::string;
  }
  basekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure_PendingPreKey::mutable_basekey() {
  set_has_basekey();
  if (basekey_ == &::google::protobuf::internal::kEmptyString) {
    basekey_ = new ::std::string;
  }
  return basekey_;
}
inline ::std::string* SessionStructure_PendingPreKey::release_basekey() {
  clear_has_basekey();
  if (basekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = basekey_;
    basekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure_PendingPreKey::set_allocated_basekey(::std::string* basekey) {
  if (basekey_ != &::google::protobuf::internal::kEmptyString) {
    delete basekey_;
  }
  if (basekey) {
    set_has_basekey();
    basekey_ = basekey;
  } else {
    clear_has_basekey();
    basekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SessionStructure

// optional uint32 sessionVersion = 1;
inline bool SessionStructure::has_sessionversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStructure::set_has_sessionversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStructure::clear_has_sessionversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStructure::clear_sessionversion() {
  sessionversion_ = 0u;
  clear_has_sessionversion();
}
inline ::google::protobuf::uint32 SessionStructure::sessionversion() const {
  return sessionversion_;
}
inline void SessionStructure::set_sessionversion(::google::protobuf::uint32 value) {
  set_has_sessionversion();
  sessionversion_ = value;
}

// optional bytes localIdentityPublic = 2;
inline bool SessionStructure::has_localidentitypublic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStructure::set_has_localidentitypublic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStructure::clear_has_localidentitypublic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStructure::clear_localidentitypublic() {
  if (localidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
    localidentitypublic_->clear();
  }
  clear_has_localidentitypublic();
}
inline const ::std::string& SessionStructure::localidentitypublic() const {
  return *localidentitypublic_;
}
inline void SessionStructure::set_localidentitypublic(const ::std::string& value) {
  set_has_localidentitypublic();
  if (localidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    localidentitypublic_ = new ::std::string;
  }
  localidentitypublic_->assign(value);
}
inline void SessionStructure::set_localidentitypublic(const char* value) {
  set_has_localidentitypublic();
  if (localidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    localidentitypublic_ = new ::std::string;
  }
  localidentitypublic_->assign(value);
}
inline void SessionStructure::set_localidentitypublic(const void* value, size_t size) {
  set_has_localidentitypublic();
  if (localidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    localidentitypublic_ = new ::std::string;
  }
  localidentitypublic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure::mutable_localidentitypublic() {
  set_has_localidentitypublic();
  if (localidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    localidentitypublic_ = new ::std::string;
  }
  return localidentitypublic_;
}
inline ::std::string* SessionStructure::release_localidentitypublic() {
  clear_has_localidentitypublic();
  if (localidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localidentitypublic_;
    localidentitypublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure::set_allocated_localidentitypublic(::std::string* localidentitypublic) {
  if (localidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
    delete localidentitypublic_;
  }
  if (localidentitypublic) {
    set_has_localidentitypublic();
    localidentitypublic_ = localidentitypublic;
  } else {
    clear_has_localidentitypublic();
    localidentitypublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes remoteIdentityPublic = 3;
inline bool SessionStructure::has_remoteidentitypublic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionStructure::set_has_remoteidentitypublic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionStructure::clear_has_remoteidentitypublic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionStructure::clear_remoteidentitypublic() {
  if (remoteidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
    remoteidentitypublic_->clear();
  }
  clear_has_remoteidentitypublic();
}
inline const ::std::string& SessionStructure::remoteidentitypublic() const {
  return *remoteidentitypublic_;
}
inline void SessionStructure::set_remoteidentitypublic(const ::std::string& value) {
  set_has_remoteidentitypublic();
  if (remoteidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    remoteidentitypublic_ = new ::std::string;
  }
  remoteidentitypublic_->assign(value);
}
inline void SessionStructure::set_remoteidentitypublic(const char* value) {
  set_has_remoteidentitypublic();
  if (remoteidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    remoteidentitypublic_ = new ::std::string;
  }
  remoteidentitypublic_->assign(value);
}
inline void SessionStructure::set_remoteidentitypublic(const void* value, size_t size) {
  set_has_remoteidentitypublic();
  if (remoteidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    remoteidentitypublic_ = new ::std::string;
  }
  remoteidentitypublic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure::mutable_remoteidentitypublic() {
  set_has_remoteidentitypublic();
  if (remoteidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    remoteidentitypublic_ = new ::std::string;
  }
  return remoteidentitypublic_;
}
inline ::std::string* SessionStructure::release_remoteidentitypublic() {
  clear_has_remoteidentitypublic();
  if (remoteidentitypublic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remoteidentitypublic_;
    remoteidentitypublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure::set_allocated_remoteidentitypublic(::std::string* remoteidentitypublic) {
  if (remoteidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
    delete remoteidentitypublic_;
  }
  if (remoteidentitypublic) {
    set_has_remoteidentitypublic();
    remoteidentitypublic_ = remoteidentitypublic;
  } else {
    clear_has_remoteidentitypublic();
    remoteidentitypublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes rootKey = 4;
inline bool SessionStructure::has_rootkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionStructure::set_has_rootkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionStructure::clear_has_rootkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionStructure::clear_rootkey() {
  if (rootkey_ != &::google::protobuf::internal::kEmptyString) {
    rootkey_->clear();
  }
  clear_has_rootkey();
}
inline const ::std::string& SessionStructure::rootkey() const {
  return *rootkey_;
}
inline void SessionStructure::set_rootkey(const ::std::string& value) {
  set_has_rootkey();
  if (rootkey_ == &::google::protobuf::internal::kEmptyString) {
    rootkey_ = new ::std::string;
  }
  rootkey_->assign(value);
}
inline void SessionStructure::set_rootkey(const char* value) {
  set_has_rootkey();
  if (rootkey_ == &::google::protobuf::internal::kEmptyString) {
    rootkey_ = new ::std::string;
  }
  rootkey_->assign(value);
}
inline void SessionStructure::set_rootkey(const void* value, size_t size) {
  set_has_rootkey();
  if (rootkey_ == &::google::protobuf::internal::kEmptyString) {
    rootkey_ = new ::std::string;
  }
  rootkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure::mutable_rootkey() {
  set_has_rootkey();
  if (rootkey_ == &::google::protobuf::internal::kEmptyString) {
    rootkey_ = new ::std::string;
  }
  return rootkey_;
}
inline ::std::string* SessionStructure::release_rootkey() {
  clear_has_rootkey();
  if (rootkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rootkey_;
    rootkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure::set_allocated_rootkey(::std::string* rootkey) {
  if (rootkey_ != &::google::protobuf::internal::kEmptyString) {
    delete rootkey_;
  }
  if (rootkey) {
    set_has_rootkey();
    rootkey_ = rootkey;
  } else {
    clear_has_rootkey();
    rootkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 previousCounter = 5;
inline bool SessionStructure::has_previouscounter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionStructure::set_has_previouscounter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionStructure::clear_has_previouscounter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionStructure::clear_previouscounter() {
  previouscounter_ = 0u;
  clear_has_previouscounter();
}
inline ::google::protobuf::uint32 SessionStructure::previouscounter() const {
  return previouscounter_;
}
inline void SessionStructure::set_previouscounter(::google::protobuf::uint32 value) {
  set_has_previouscounter();
  previouscounter_ = value;
}

// optional .textsecure.SessionStructure.Chain senderChain = 6;
inline bool SessionStructure::has_senderchain() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SessionStructure::set_has_senderchain() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SessionStructure::clear_has_senderchain() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SessionStructure::clear_senderchain() {
  if (senderchain_ != NULL) senderchain_->::textsecure::SessionStructure_Chain::Clear();
  clear_has_senderchain();
}
inline const ::textsecure::SessionStructure_Chain& SessionStructure::senderchain() const {
  return senderchain_ != NULL ? *senderchain_ : *default_instance_->senderchain_;
}
inline ::textsecure::SessionStructure_Chain* SessionStructure::mutable_senderchain() {
  set_has_senderchain();
  if (senderchain_ == NULL) senderchain_ = new ::textsecure::SessionStructure_Chain;
  return senderchain_;
}
inline ::textsecure::SessionStructure_Chain* SessionStructure::release_senderchain() {
  clear_has_senderchain();
  ::textsecure::SessionStructure_Chain* temp = senderchain_;
  senderchain_ = NULL;
  return temp;
}
inline void SessionStructure::set_allocated_senderchain(::textsecure::SessionStructure_Chain* senderchain) {
  delete senderchain_;
  senderchain_ = senderchain;
  if (senderchain) {
    set_has_senderchain();
  } else {
    clear_has_senderchain();
  }
}

// repeated .textsecure.SessionStructure.Chain receiverChains = 7;
inline int SessionStructure::receiverchains_size() const {
  return receiverchains_.size();
}
inline void SessionStructure::clear_receiverchains() {
  receiverchains_.Clear();
}
inline const ::textsecure::SessionStructure_Chain& SessionStructure::receiverchains(int index) const {
  return receiverchains_.Get(index);
}
inline ::textsecure::SessionStructure_Chain* SessionStructure::mutable_receiverchains(int index) {
  return receiverchains_.Mutable(index);
}
inline ::textsecure::SessionStructure_Chain* SessionStructure::add_receiverchains() {
  return receiverchains_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain >&
SessionStructure::receiverchains() const {
  return receiverchains_;
}
inline ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure_Chain >*
SessionStructure::mutable_receiverchains() {
  return &receiverchains_;
}

// optional .textsecure.SessionStructure.PendingKeyExchange pendingKeyExchange = 8;
inline bool SessionStructure::has_pendingkeyexchange() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SessionStructure::set_has_pendingkeyexchange() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SessionStructure::clear_has_pendingkeyexchange() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SessionStructure::clear_pendingkeyexchange() {
  if (pendingkeyexchange_ != NULL) pendingkeyexchange_->::textsecure::SessionStructure_PendingKeyExchange::Clear();
  clear_has_pendingkeyexchange();
}
inline const ::textsecure::SessionStructure_PendingKeyExchange& SessionStructure::pendingkeyexchange() const {
  return pendingkeyexchange_ != NULL ? *pendingkeyexchange_ : *default_instance_->pendingkeyexchange_;
}
inline ::textsecure::SessionStructure_PendingKeyExchange* SessionStructure::mutable_pendingkeyexchange() {
  set_has_pendingkeyexchange();
  if (pendingkeyexchange_ == NULL) pendingkeyexchange_ = new ::textsecure::SessionStructure_PendingKeyExchange;
  return pendingkeyexchange_;
}
inline ::textsecure::SessionStructure_PendingKeyExchange* SessionStructure::release_pendingkeyexchange() {
  clear_has_pendingkeyexchange();
  ::textsecure::SessionStructure_PendingKeyExchange* temp = pendingkeyexchange_;
  pendingkeyexchange_ = NULL;
  return temp;
}
inline void SessionStructure::set_allocated_pendingkeyexchange(::textsecure::SessionStructure_PendingKeyExchange* pendingkeyexchange) {
  delete pendingkeyexchange_;
  pendingkeyexchange_ = pendingkeyexchange;
  if (pendingkeyexchange) {
    set_has_pendingkeyexchange();
  } else {
    clear_has_pendingkeyexchange();
  }
}

// optional .textsecure.SessionStructure.PendingPreKey pendingPreKey = 9;
inline bool SessionStructure::has_pendingprekey() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SessionStructure::set_has_pendingprekey() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SessionStructure::clear_has_pendingprekey() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SessionStructure::clear_pendingprekey() {
  if (pendingprekey_ != NULL) pendingprekey_->::textsecure::SessionStructure_PendingPreKey::Clear();
  clear_has_pendingprekey();
}
inline const ::textsecure::SessionStructure_PendingPreKey& SessionStructure::pendingprekey() const {
  return pendingprekey_ != NULL ? *pendingprekey_ : *default_instance_->pendingprekey_;
}
inline ::textsecure::SessionStructure_PendingPreKey* SessionStructure::mutable_pendingprekey() {
  set_has_pendingprekey();
  if (pendingprekey_ == NULL) pendingprekey_ = new ::textsecure::SessionStructure_PendingPreKey;
  return pendingprekey_;
}
inline ::textsecure::SessionStructure_PendingPreKey* SessionStructure::release_pendingprekey() {
  clear_has_pendingprekey();
  ::textsecure::SessionStructure_PendingPreKey* temp = pendingprekey_;
  pendingprekey_ = NULL;
  return temp;
}
inline void SessionStructure::set_allocated_pendingprekey(::textsecure::SessionStructure_PendingPreKey* pendingprekey) {
  delete pendingprekey_;
  pendingprekey_ = pendingprekey;
  if (pendingprekey) {
    set_has_pendingprekey();
  } else {
    clear_has_pendingprekey();
  }
}

// optional uint32 remoteRegistrationId = 10;
inline bool SessionStructure::has_remoteregistrationid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SessionStructure::set_has_remoteregistrationid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SessionStructure::clear_has_remoteregistrationid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SessionStructure::clear_remoteregistrationid() {
  remoteregistrationid_ = 0u;
  clear_has_remoteregistrationid();
}
inline ::google::protobuf::uint32 SessionStructure::remoteregistrationid() const {
  return remoteregistrationid_;
}
inline void SessionStructure::set_remoteregistrationid(::google::protobuf::uint32 value) {
  set_has_remoteregistrationid();
  remoteregistrationid_ = value;
}

// optional uint32 localRegistrationId = 11;
inline bool SessionStructure::has_localregistrationid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SessionStructure::set_has_localregistrationid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SessionStructure::clear_has_localregistrationid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SessionStructure::clear_localregistrationid() {
  localregistrationid_ = 0u;
  clear_has_localregistrationid();
}
inline ::google::protobuf::uint32 SessionStructure::localregistrationid() const {
  return localregistrationid_;
}
inline void SessionStructure::set_localregistrationid(::google::protobuf::uint32 value) {
  set_has_localregistrationid();
  localregistrationid_ = value;
}

// optional bool needsRefresh = 12;
inline bool SessionStructure::has_needsrefresh() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SessionStructure::set_has_needsrefresh() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SessionStructure::clear_has_needsrefresh() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SessionStructure::clear_needsrefresh() {
  needsrefresh_ = false;
  clear_has_needsrefresh();
}
inline bool SessionStructure::needsrefresh() const {
  return needsrefresh_;
}
inline void SessionStructure::set_needsrefresh(bool value) {
  set_has_needsrefresh();
  needsrefresh_ = value;
}

// optional bytes aliceBaseKey = 13;
inline bool SessionStructure::has_alicebasekey() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SessionStructure::set_has_alicebasekey() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SessionStructure::clear_has_alicebasekey() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SessionStructure::clear_alicebasekey() {
  if (alicebasekey_ != &::google::protobuf::internal::kEmptyString) {
    alicebasekey_->clear();
  }
  clear_has_alicebasekey();
}
inline const ::std::string& SessionStructure::alicebasekey() const {
  return *alicebasekey_;
}
inline void SessionStructure::set_alicebasekey(const ::std::string& value) {
  set_has_alicebasekey();
  if (alicebasekey_ == &::google::protobuf::internal::kEmptyString) {
    alicebasekey_ = new ::std::string;
  }
  alicebasekey_->assign(value);
}
inline void SessionStructure::set_alicebasekey(const char* value) {
  set_has_alicebasekey();
  if (alicebasekey_ == &::google::protobuf::internal::kEmptyString) {
    alicebasekey_ = new ::std::string;
  }
  alicebasekey_->assign(value);
}
inline void SessionStructure::set_alicebasekey(const void* value, size_t size) {
  set_has_alicebasekey();
  if (alicebasekey_ == &::google::protobuf::internal::kEmptyString) {
    alicebasekey_ = new ::std::string;
  }
  alicebasekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionStructure::mutable_alicebasekey() {
  set_has_alicebasekey();
  if (alicebasekey_ == &::google::protobuf::internal::kEmptyString) {
    alicebasekey_ = new ::std::string;
  }
  return alicebasekey_;
}
inline ::std::string* SessionStructure::release_alicebasekey() {
  clear_has_alicebasekey();
  if (alicebasekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alicebasekey_;
    alicebasekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionStructure::set_allocated_alicebasekey(::std::string* alicebasekey) {
  if (alicebasekey_ != &::google::protobuf::internal::kEmptyString) {
    delete alicebasekey_;
  }
  if (alicebasekey) {
    set_has_alicebasekey();
    alicebasekey_ = alicebasekey;
  } else {
    clear_has_alicebasekey();
    alicebasekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RecordStructure

// optional .textsecure.SessionStructure currentSession = 1;
inline bool RecordStructure::has_currentsession() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordStructure::set_has_currentsession() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordStructure::clear_has_currentsession() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordStructure::clear_currentsession() {
  if (currentsession_ != NULL) currentsession_->::textsecure::SessionStructure::Clear();
  clear_has_currentsession();
}
inline const ::textsecure::SessionStructure& RecordStructure::currentsession() const {
  return currentsession_ != NULL ? *currentsession_ : *default_instance_->currentsession_;
}
inline ::textsecure::SessionStructure* RecordStructure::mutable_currentsession() {
  set_has_currentsession();
  if (currentsession_ == NULL) currentsession_ = new ::textsecure::SessionStructure;
  return currentsession_;
}
inline ::textsecure::SessionStructure* RecordStructure::release_currentsession() {
  clear_has_currentsession();
  ::textsecure::SessionStructure* temp = currentsession_;
  currentsession_ = NULL;
  return temp;
}
inline void RecordStructure::set_allocated_currentsession(::textsecure::SessionStructure* currentsession) {
  delete currentsession_;
  currentsession_ = currentsession;
  if (currentsession) {
    set_has_currentsession();
  } else {
    clear_has_currentsession();
  }
}

// repeated .textsecure.SessionStructure previousSessions = 2;
inline int RecordStructure::previoussessions_size() const {
  return previoussessions_.size();
}
inline void RecordStructure::clear_previoussessions() {
  previoussessions_.Clear();
}
inline const ::textsecure::SessionStructure& RecordStructure::previoussessions(int index) const {
  return previoussessions_.Get(index);
}
inline ::textsecure::SessionStructure* RecordStructure::mutable_previoussessions(int index) {
  return previoussessions_.Mutable(index);
}
inline ::textsecure::SessionStructure* RecordStructure::add_previoussessions() {
  return previoussessions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure >&
RecordStructure::previoussessions() const {
  return previoussessions_;
}
inline ::google::protobuf::RepeatedPtrField< ::textsecure::SessionStructure >*
RecordStructure::mutable_previoussessions() {
  return &previoussessions_;
}

// -------------------------------------------------------------------

// PreKeyRecordStructure

// optional uint32 id = 1;
inline bool PreKeyRecordStructure::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreKeyRecordStructure::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreKeyRecordStructure::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreKeyRecordStructure::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PreKeyRecordStructure::id() const {
  return id_;
}
inline void PreKeyRecordStructure::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes publicKey = 2;
inline bool PreKeyRecordStructure::has_publickey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreKeyRecordStructure::set_has_publickey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreKeyRecordStructure::clear_has_publickey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreKeyRecordStructure::clear_publickey() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    publickey_->clear();
  }
  clear_has_publickey();
}
inline const ::std::string& PreKeyRecordStructure::publickey() const {
  return *publickey_;
}
inline void PreKeyRecordStructure::set_publickey(const ::std::string& value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void PreKeyRecordStructure::set_publickey(const char* value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void PreKeyRecordStructure::set_publickey(const void* value, size_t size) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreKeyRecordStructure::mutable_publickey() {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  return publickey_;
}
inline ::std::string* PreKeyRecordStructure::release_publickey() {
  clear_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickey_;
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreKeyRecordStructure::set_allocated_publickey(::std::string* publickey) {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (publickey) {
    set_has_publickey();
    publickey_ = publickey;
  } else {
    clear_has_publickey();
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes privateKey = 3;
inline bool PreKeyRecordStructure::has_privatekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreKeyRecordStructure::set_has_privatekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreKeyRecordStructure::clear_has_privatekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreKeyRecordStructure::clear_privatekey() {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    privatekey_->clear();
  }
  clear_has_privatekey();
}
inline const ::std::string& PreKeyRecordStructure::privatekey() const {
  return *privatekey_;
}
inline void PreKeyRecordStructure::set_privatekey(const ::std::string& value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void PreKeyRecordStructure::set_privatekey(const char* value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void PreKeyRecordStructure::set_privatekey(const void* value, size_t size) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreKeyRecordStructure::mutable_privatekey() {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  return privatekey_;
}
inline ::std::string* PreKeyRecordStructure::release_privatekey() {
  clear_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = privatekey_;
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreKeyRecordStructure::set_allocated_privatekey(::std::string* privatekey) {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (privatekey) {
    set_has_privatekey();
    privatekey_ = privatekey;
  } else {
    clear_has_privatekey();
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedPreKeyRecordStructure

// optional uint32 id = 1;
inline bool SignedPreKeyRecordStructure::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedPreKeyRecordStructure::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedPreKeyRecordStructure::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedPreKeyRecordStructure::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SignedPreKeyRecordStructure::id() const {
  return id_;
}
inline void SignedPreKeyRecordStructure::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes publicKey = 2;
inline bool SignedPreKeyRecordStructure::has_publickey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedPreKeyRecordStructure::set_has_publickey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedPreKeyRecordStructure::clear_has_publickey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedPreKeyRecordStructure::clear_publickey() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    publickey_->clear();
  }
  clear_has_publickey();
}
inline const ::std::string& SignedPreKeyRecordStructure::publickey() const {
  return *publickey_;
}
inline void SignedPreKeyRecordStructure::set_publickey(const ::std::string& value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void SignedPreKeyRecordStructure::set_publickey(const char* value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void SignedPreKeyRecordStructure::set_publickey(const void* value, size_t size) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedPreKeyRecordStructure::mutable_publickey() {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  return publickey_;
}
inline ::std::string* SignedPreKeyRecordStructure::release_publickey() {
  clear_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickey_;
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedPreKeyRecordStructure::set_allocated_publickey(::std::string* publickey) {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (publickey) {
    set_has_publickey();
    publickey_ = publickey;
  } else {
    clear_has_publickey();
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes privateKey = 3;
inline bool SignedPreKeyRecordStructure::has_privatekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedPreKeyRecordStructure::set_has_privatekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedPreKeyRecordStructure::clear_has_privatekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedPreKeyRecordStructure::clear_privatekey() {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    privatekey_->clear();
  }
  clear_has_privatekey();
}
inline const ::std::string& SignedPreKeyRecordStructure::privatekey() const {
  return *privatekey_;
}
inline void SignedPreKeyRecordStructure::set_privatekey(const ::std::string& value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void SignedPreKeyRecordStructure::set_privatekey(const char* value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void SignedPreKeyRecordStructure::set_privatekey(const void* value, size_t size) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedPreKeyRecordStructure::mutable_privatekey() {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  return privatekey_;
}
inline ::std::string* SignedPreKeyRecordStructure::release_privatekey() {
  clear_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = privatekey_;
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedPreKeyRecordStructure::set_allocated_privatekey(::std::string* privatekey) {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (privatekey) {
    set_has_privatekey();
    privatekey_ = privatekey;
  } else {
    clear_has_privatekey();
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 4;
inline bool SignedPreKeyRecordStructure::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedPreKeyRecordStructure::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedPreKeyRecordStructure::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedPreKeyRecordStructure::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedPreKeyRecordStructure::signature() const {
  return *signature_;
}
inline void SignedPreKeyRecordStructure::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedPreKeyRecordStructure::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedPreKeyRecordStructure::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedPreKeyRecordStructure::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedPreKeyRecordStructure::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedPreKeyRecordStructure::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 timestamp = 5;
inline bool SignedPreKeyRecordStructure::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignedPreKeyRecordStructure::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignedPreKeyRecordStructure::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignedPreKeyRecordStructure::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 SignedPreKeyRecordStructure::timestamp() const {
  return timestamp_;
}
inline void SignedPreKeyRecordStructure::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// IdentityKeyPairStructure

// optional bytes publicKey = 1;
inline bool IdentityKeyPairStructure::has_publickey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdentityKeyPairStructure::set_has_publickey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdentityKeyPairStructure::clear_has_publickey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdentityKeyPairStructure::clear_publickey() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    publickey_->clear();
  }
  clear_has_publickey();
}
inline const ::std::string& IdentityKeyPairStructure::publickey() const {
  return *publickey_;
}
inline void IdentityKeyPairStructure::set_publickey(const ::std::string& value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void IdentityKeyPairStructure::set_publickey(const char* value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void IdentityKeyPairStructure::set_publickey(const void* value, size_t size) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentityKeyPairStructure::mutable_publickey() {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  return publickey_;
}
inline ::std::string* IdentityKeyPairStructure::release_publickey() {
  clear_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickey_;
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentityKeyPairStructure::set_allocated_publickey(::std::string* publickey) {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (publickey) {
    set_has_publickey();
    publickey_ = publickey;
  } else {
    clear_has_publickey();
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes privateKey = 2;
inline bool IdentityKeyPairStructure::has_privatekey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdentityKeyPairStructure::set_has_privatekey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdentityKeyPairStructure::clear_has_privatekey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdentityKeyPairStructure::clear_privatekey() {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    privatekey_->clear();
  }
  clear_has_privatekey();
}
inline const ::std::string& IdentityKeyPairStructure::privatekey() const {
  return *privatekey_;
}
inline void IdentityKeyPairStructure::set_privatekey(const ::std::string& value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void IdentityKeyPairStructure::set_privatekey(const char* value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void IdentityKeyPairStructure::set_privatekey(const void* value, size_t size) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentityKeyPairStructure::mutable_privatekey() {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  return privatekey_;
}
inline ::std::string* IdentityKeyPairStructure::release_privatekey() {
  clear_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = privatekey_;
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentityKeyPairStructure::set_allocated_privatekey(::std::string* privatekey) {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (privatekey) {
    set_has_privatekey();
    privatekey_ = privatekey;
  } else {
    clear_has_privatekey();
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SenderKeyStateStructure_SenderChainKey

// optional uint32 iteration = 1;
inline bool SenderKeyStateStructure_SenderChainKey::has_iteration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SenderKeyStateStructure_SenderChainKey::set_has_iteration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SenderKeyStateStructure_SenderChainKey::clear_has_iteration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SenderKeyStateStructure_SenderChainKey::clear_iteration() {
  iteration_ = 0u;
  clear_has_iteration();
}
inline ::google::protobuf::uint32 SenderKeyStateStructure_SenderChainKey::iteration() const {
  return iteration_;
}
inline void SenderKeyStateStructure_SenderChainKey::set_iteration(::google::protobuf::uint32 value) {
  set_has_iteration();
  iteration_ = value;
}

// optional bytes seed = 2;
inline bool SenderKeyStateStructure_SenderChainKey::has_seed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SenderKeyStateStructure_SenderChainKey::set_has_seed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SenderKeyStateStructure_SenderChainKey::clear_has_seed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SenderKeyStateStructure_SenderChainKey::clear_seed() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& SenderKeyStateStructure_SenderChainKey::seed() const {
  return *seed_;
}
inline void SenderKeyStateStructure_SenderChainKey::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void SenderKeyStateStructure_SenderChainKey::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void SenderKeyStateStructure_SenderChainKey::set_seed(const void* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SenderKeyStateStructure_SenderChainKey::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  return seed_;
}
inline ::std::string* SenderKeyStateStructure_SenderChainKey::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SenderKeyStateStructure_SenderChainKey::set_allocated_seed(::std::string* seed) {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (seed) {
    set_has_seed();
    seed_ = seed;
  } else {
    clear_has_seed();
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SenderKeyStateStructure_SenderMessageKey

// optional uint32 iteration = 1;
inline bool SenderKeyStateStructure_SenderMessageKey::has_iteration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SenderKeyStateStructure_SenderMessageKey::set_has_iteration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SenderKeyStateStructure_SenderMessageKey::clear_has_iteration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SenderKeyStateStructure_SenderMessageKey::clear_iteration() {
  iteration_ = 0u;
  clear_has_iteration();
}
inline ::google::protobuf::uint32 SenderKeyStateStructure_SenderMessageKey::iteration() const {
  return iteration_;
}
inline void SenderKeyStateStructure_SenderMessageKey::set_iteration(::google::protobuf::uint32 value) {
  set_has_iteration();
  iteration_ = value;
}

// optional bytes seed = 2;
inline bool SenderKeyStateStructure_SenderMessageKey::has_seed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SenderKeyStateStructure_SenderMessageKey::set_has_seed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SenderKeyStateStructure_SenderMessageKey::clear_has_seed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SenderKeyStateStructure_SenderMessageKey::clear_seed() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& SenderKeyStateStructure_SenderMessageKey::seed() const {
  return *seed_;
}
inline void SenderKeyStateStructure_SenderMessageKey::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void SenderKeyStateStructure_SenderMessageKey::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void SenderKeyStateStructure_SenderMessageKey::set_seed(const void* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SenderKeyStateStructure_SenderMessageKey::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  return seed_;
}
inline ::std::string* SenderKeyStateStructure_SenderMessageKey::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SenderKeyStateStructure_SenderMessageKey::set_allocated_seed(::std::string* seed) {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (seed) {
    set_has_seed();
    seed_ = seed;
  } else {
    clear_has_seed();
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SenderKeyStateStructure_SenderSigningKey

// optional bytes public = 1;
inline bool SenderKeyStateStructure_SenderSigningKey::has_public_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SenderKeyStateStructure_SenderSigningKey::set_has_public_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SenderKeyStateStructure_SenderSigningKey::clear_has_public_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SenderKeyStateStructure_SenderSigningKey::clear_public_() {
  if (public__ != &::google::protobuf::internal::kEmptyString) {
    public__->clear();
  }
  clear_has_public_();
}
inline const ::std::string& SenderKeyStateStructure_SenderSigningKey::public_() const {
  return *public__;
}
inline void SenderKeyStateStructure_SenderSigningKey::set_public_(const ::std::string& value) {
  set_has_public_();
  if (public__ == &::google::protobuf::internal::kEmptyString) {
    public__ = new ::std::string;
  }
  public__->assign(value);
}
inline void SenderKeyStateStructure_SenderSigningKey::set_public_(const char* value) {
  set_has_public_();
  if (public__ == &::google::protobuf::internal::kEmptyString) {
    public__ = new ::std::string;
  }
  public__->assign(value);
}
inline void SenderKeyStateStructure_SenderSigningKey::set_public_(const void* value, size_t size) {
  set_has_public_();
  if (public__ == &::google::protobuf::internal::kEmptyString) {
    public__ = new ::std::string;
  }
  public__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SenderKeyStateStructure_SenderSigningKey::mutable_public_() {
  set_has_public_();
  if (public__ == &::google::protobuf::internal::kEmptyString) {
    public__ = new ::std::string;
  }
  return public__;
}
inline ::std::string* SenderKeyStateStructure_SenderSigningKey::release_public_() {
  clear_has_public_();
  if (public__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public__;
    public__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SenderKeyStateStructure_SenderSigningKey::set_allocated_public_(::std::string* public_) {
  if (public__ != &::google::protobuf::internal::kEmptyString) {
    delete public__;
  }
  if (public_) {
    set_has_public_();
    public__ = public_;
  } else {
    clear_has_public_();
    public__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes private = 2;
inline bool SenderKeyStateStructure_SenderSigningKey::has_private_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SenderKeyStateStructure_SenderSigningKey::set_has_private_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SenderKeyStateStructure_SenderSigningKey::clear_has_private_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SenderKeyStateStructure_SenderSigningKey::clear_private_() {
  if (private__ != &::google::protobuf::internal::kEmptyString) {
    private__->clear();
  }
  clear_has_private_();
}
inline const ::std::string& SenderKeyStateStructure_SenderSigningKey::private_() const {
  return *private__;
}
inline void SenderKeyStateStructure_SenderSigningKey::set_private_(const ::std::string& value) {
  set_has_private_();
  if (private__ == &::google::protobuf::internal::kEmptyString) {
    private__ = new ::std::string;
  }
  private__->assign(value);
}
inline void SenderKeyStateStructure_SenderSigningKey::set_private_(const char* value) {
  set_has_private_();
  if (private__ == &::google::protobuf::internal::kEmptyString) {
    private__ = new ::std::string;
  }
  private__->assign(value);
}
inline void SenderKeyStateStructure_SenderSigningKey::set_private_(const void* value, size_t size) {
  set_has_private_();
  if (private__ == &::google::protobuf::internal::kEmptyString) {
    private__ = new ::std::string;
  }
  private__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SenderKeyStateStructure_SenderSigningKey::mutable_private_() {
  set_has_private_();
  if (private__ == &::google::protobuf::internal::kEmptyString) {
    private__ = new ::std::string;
  }
  return private__;
}
inline ::std::string* SenderKeyStateStructure_SenderSigningKey::release_private_() {
  clear_has_private_();
  if (private__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private__;
    private__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SenderKeyStateStructure_SenderSigningKey::set_allocated_private_(::std::string* private_) {
  if (private__ != &::google::protobuf::internal::kEmptyString) {
    delete private__;
  }
  if (private_) {
    set_has_private_();
    private__ = private_;
  } else {
    clear_has_private_();
    private__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SenderKeyStateStructure

// optional uint32 senderKeyId = 1;
inline bool SenderKeyStateStructure::has_senderkeyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SenderKeyStateStructure::set_has_senderkeyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SenderKeyStateStructure::clear_has_senderkeyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SenderKeyStateStructure::clear_senderkeyid() {
  senderkeyid_ = 0u;
  clear_has_senderkeyid();
}
inline ::google::protobuf::uint32 SenderKeyStateStructure::senderkeyid() const {
  return senderkeyid_;
}
inline void SenderKeyStateStructure::set_senderkeyid(::google::protobuf::uint32 value) {
  set_has_senderkeyid();
  senderkeyid_ = value;
}

// optional .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKey = 2;
inline bool SenderKeyStateStructure::has_senderchainkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SenderKeyStateStructure::set_has_senderchainkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SenderKeyStateStructure::clear_has_senderchainkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SenderKeyStateStructure::clear_senderchainkey() {
  if (senderchainkey_ != NULL) senderchainkey_->::textsecure::SenderKeyStateStructure_SenderChainKey::Clear();
  clear_has_senderchainkey();
}
inline const ::textsecure::SenderKeyStateStructure_SenderChainKey& SenderKeyStateStructure::senderchainkey() const {
  return senderchainkey_ != NULL ? *senderchainkey_ : *default_instance_->senderchainkey_;
}
inline ::textsecure::SenderKeyStateStructure_SenderChainKey* SenderKeyStateStructure::mutable_senderchainkey() {
  set_has_senderchainkey();
  if (senderchainkey_ == NULL) senderchainkey_ = new ::textsecure::SenderKeyStateStructure_SenderChainKey;
  return senderchainkey_;
}
inline ::textsecure::SenderKeyStateStructure_SenderChainKey* SenderKeyStateStructure::release_senderchainkey() {
  clear_has_senderchainkey();
  ::textsecure::SenderKeyStateStructure_SenderChainKey* temp = senderchainkey_;
  senderchainkey_ = NULL;
  return temp;
}
inline void SenderKeyStateStructure::set_allocated_senderchainkey(::textsecure::SenderKeyStateStructure_SenderChainKey* senderchainkey) {
  delete senderchainkey_;
  senderchainkey_ = senderchainkey;
  if (senderchainkey) {
    set_has_senderchainkey();
  } else {
    clear_has_senderchainkey();
  }
}

// optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
inline bool SenderKeyStateStructure::has_sendersigningkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SenderKeyStateStructure::set_has_sendersigningkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SenderKeyStateStructure::clear_has_sendersigningkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SenderKeyStateStructure::clear_sendersigningkey() {
  if (sendersigningkey_ != NULL) sendersigningkey_->::textsecure::SenderKeyStateStructure_SenderSigningKey::Clear();
  clear_has_sendersigningkey();
}
inline const ::textsecure::SenderKeyStateStructure_SenderSigningKey& SenderKeyStateStructure::sendersigningkey() const {
  return sendersigningkey_ != NULL ? *sendersigningkey_ : *default_instance_->sendersigningkey_;
}
inline ::textsecure::SenderKeyStateStructure_SenderSigningKey* SenderKeyStateStructure::mutable_sendersigningkey() {
  set_has_sendersigningkey();
  if (sendersigningkey_ == NULL) sendersigningkey_ = new ::textsecure::SenderKeyStateStructure_SenderSigningKey;
  return sendersigningkey_;
}
inline ::textsecure::SenderKeyStateStructure_SenderSigningKey* SenderKeyStateStructure::release_sendersigningkey() {
  clear_has_sendersigningkey();
  ::textsecure::SenderKeyStateStructure_SenderSigningKey* temp = sendersigningkey_;
  sendersigningkey_ = NULL;
  return temp;
}
inline void SenderKeyStateStructure::set_allocated_sendersigningkey(::textsecure::SenderKeyStateStructure_SenderSigningKey* sendersigningkey) {
  delete sendersigningkey_;
  sendersigningkey_ = sendersigningkey;
  if (sendersigningkey) {
    set_has_sendersigningkey();
  } else {
    clear_has_sendersigningkey();
  }
}

// repeated .textsecure.SenderKeyStateStructure.SenderMessageKey senderMessageKeys = 4;
inline int SenderKeyStateStructure::sendermessagekeys_size() const {
  return sendermessagekeys_.size();
}
inline void SenderKeyStateStructure::clear_sendermessagekeys() {
  sendermessagekeys_.Clear();
}
inline const ::textsecure::SenderKeyStateStructure_SenderMessageKey& SenderKeyStateStructure::sendermessagekeys(int index) const {
  return sendermessagekeys_.Get(index);
}
inline ::textsecure::SenderKeyStateStructure_SenderMessageKey* SenderKeyStateStructure::mutable_sendermessagekeys(int index) {
  return sendermessagekeys_.Mutable(index);
}
inline ::textsecure::SenderKeyStateStructure_SenderMessageKey* SenderKeyStateStructure::add_sendermessagekeys() {
  return sendermessagekeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure_SenderMessageKey >&
SenderKeyStateStructure::sendermessagekeys() const {
  return sendermessagekeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure_SenderMessageKey >*
SenderKeyStateStructure::mutable_sendermessagekeys() {
  return &sendermessagekeys_;
}

// -------------------------------------------------------------------

// SenderKeyRecordStructure

// repeated .textsecure.SenderKeyStateStructure senderKeyStates = 1;
inline int SenderKeyRecordStructure::senderkeystates_size() const {
  return senderkeystates_.size();
}
inline void SenderKeyRecordStructure::clear_senderkeystates() {
  senderkeystates_.Clear();
}
inline const ::textsecure::SenderKeyStateStructure& SenderKeyRecordStructure::senderkeystates(int index) const {
  return senderkeystates_.Get(index);
}
inline ::textsecure::SenderKeyStateStructure* SenderKeyRecordStructure::mutable_senderkeystates(int index) {
  return senderkeystates_.Mutable(index);
}
inline ::textsecure::SenderKeyStateStructure* SenderKeyRecordStructure::add_senderkeystates() {
  return senderkeystates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure >&
SenderKeyRecordStructure::senderkeystates() const {
  return senderkeystates_;
}
inline ::google::protobuf::RepeatedPtrField< ::textsecure::SenderKeyStateStructure >*
SenderKeyRecordStructure::mutable_senderkeystates() {
  return &senderkeystates_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace textsecure

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protobuf_2fLocalStorageProtocol_2eproto__INCLUDED
