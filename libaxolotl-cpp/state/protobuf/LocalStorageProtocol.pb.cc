// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protobuf/LocalStorageProtocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "protobuf/LocalStorageProtocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace textsecure {

namespace {

const ::google::protobuf::Descriptor* SessionStructure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SessionStructure_reflection_ = NULL;
const ::google::protobuf::Descriptor* SessionStructure_Chain_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SessionStructure_Chain_reflection_ = NULL;
const ::google::protobuf::Descriptor* SessionStructure_Chain_ChainKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SessionStructure_Chain_ChainKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* SessionStructure_Chain_MessageKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SessionStructure_Chain_MessageKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* SessionStructure_PendingKeyExchange_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SessionStructure_PendingKeyExchange_reflection_ = NULL;
const ::google::protobuf::Descriptor* SessionStructure_PendingPreKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SessionStructure_PendingPreKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* RecordStructure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RecordStructure_reflection_ = NULL;
const ::google::protobuf::Descriptor* PreKeyRecordStructure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PreKeyRecordStructure_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignedPreKeyRecordStructure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignedPreKeyRecordStructure_reflection_ = NULL;
const ::google::protobuf::Descriptor* IdentityKeyPairStructure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IdentityKeyPairStructure_reflection_ = NULL;
const ::google::protobuf::Descriptor* SenderKeyStateStructure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SenderKeyStateStructure_reflection_ = NULL;
const ::google::protobuf::Descriptor* SenderKeyStateStructure_SenderChainKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SenderKeyStateStructure_SenderChainKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* SenderKeyStateStructure_SenderMessageKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SenderKeyStateStructure_SenderMessageKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* SenderKeyStateStructure_SenderSigningKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SenderKeyStateStructure_SenderSigningKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* SenderKeyRecordStructure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SenderKeyRecordStructure_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto() {
  protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "protobuf/LocalStorageProtocol.proto");
  GOOGLE_CHECK(file != NULL);
  SessionStructure_descriptor_ = file->message_type(0);
  static const int SessionStructure_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, sessionversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, localidentitypublic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, remoteidentitypublic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, rootkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, previouscounter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, senderchain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, receiverchains_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, pendingkeyexchange_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, pendingprekey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, remoteregistrationid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, localregistrationid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, needsrefresh_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, alicebasekey_),
  };
  SessionStructure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SessionStructure_descriptor_,
      SessionStructure::default_instance_,
      SessionStructure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SessionStructure));
  SessionStructure_Chain_descriptor_ = SessionStructure_descriptor_->nested_type(0);
  static const int SessionStructure_Chain_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain, senderratchetkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain, senderratchetkeyprivate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain, chainkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain, messagekeys_),
  };
  SessionStructure_Chain_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SessionStructure_Chain_descriptor_,
      SessionStructure_Chain::default_instance_,
      SessionStructure_Chain_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SessionStructure_Chain));
  SessionStructure_Chain_ChainKey_descriptor_ = SessionStructure_Chain_descriptor_->nested_type(0);
  static const int SessionStructure_Chain_ChainKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_ChainKey, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_ChainKey, key_),
  };
  SessionStructure_Chain_ChainKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SessionStructure_Chain_ChainKey_descriptor_,
      SessionStructure_Chain_ChainKey::default_instance_,
      SessionStructure_Chain_ChainKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_ChainKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_ChainKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SessionStructure_Chain_ChainKey));
  SessionStructure_Chain_MessageKey_descriptor_ = SessionStructure_Chain_descriptor_->nested_type(1);
  static const int SessionStructure_Chain_MessageKey_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_MessageKey, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_MessageKey, cipherkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_MessageKey, mackey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_MessageKey, iv_),
  };
  SessionStructure_Chain_MessageKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SessionStructure_Chain_MessageKey_descriptor_,
      SessionStructure_Chain_MessageKey::default_instance_,
      SessionStructure_Chain_MessageKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_MessageKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_Chain_MessageKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SessionStructure_Chain_MessageKey));
  SessionStructure_PendingKeyExchange_descriptor_ = SessionStructure_descriptor_->nested_type(1);
  static const int SessionStructure_PendingKeyExchange_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, localbasekey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, localbasekeyprivate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, localratchetkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, localratchetkeyprivate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, localidentitykey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, localidentitykeyprivate_),
  };
  SessionStructure_PendingKeyExchange_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SessionStructure_PendingKeyExchange_descriptor_,
      SessionStructure_PendingKeyExchange::default_instance_,
      SessionStructure_PendingKeyExchange_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingKeyExchange, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SessionStructure_PendingKeyExchange));
  SessionStructure_PendingPreKey_descriptor_ = SessionStructure_descriptor_->nested_type(2);
  static const int SessionStructure_PendingPreKey_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingPreKey, prekeyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingPreKey, signedprekeyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingPreKey, basekey_),
  };
  SessionStructure_PendingPreKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SessionStructure_PendingPreKey_descriptor_,
      SessionStructure_PendingPreKey::default_instance_,
      SessionStructure_PendingPreKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingPreKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SessionStructure_PendingPreKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SessionStructure_PendingPreKey));
  RecordStructure_descriptor_ = file->message_type(1);
  static const int RecordStructure_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordStructure, currentsession_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordStructure, previoussessions_),
  };
  RecordStructure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RecordStructure_descriptor_,
      RecordStructure::default_instance_,
      RecordStructure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordStructure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecordStructure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RecordStructure));
  PreKeyRecordStructure_descriptor_ = file->message_type(2);
  static const int PreKeyRecordStructure_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreKeyRecordStructure, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreKeyRecordStructure, publickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreKeyRecordStructure, privatekey_),
  };
  PreKeyRecordStructure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PreKeyRecordStructure_descriptor_,
      PreKeyRecordStructure::default_instance_,
      PreKeyRecordStructure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreKeyRecordStructure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreKeyRecordStructure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PreKeyRecordStructure));
  SignedPreKeyRecordStructure_descriptor_ = file->message_type(3);
  static const int SignedPreKeyRecordStructure_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedPreKeyRecordStructure, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedPreKeyRecordStructure, publickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedPreKeyRecordStructure, privatekey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedPreKeyRecordStructure, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedPreKeyRecordStructure, timestamp_),
  };
  SignedPreKeyRecordStructure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignedPreKeyRecordStructure_descriptor_,
      SignedPreKeyRecordStructure::default_instance_,
      SignedPreKeyRecordStructure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedPreKeyRecordStructure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedPreKeyRecordStructure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignedPreKeyRecordStructure));
  IdentityKeyPairStructure_descriptor_ = file->message_type(4);
  static const int IdentityKeyPairStructure_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityKeyPairStructure, publickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityKeyPairStructure, privatekey_),
  };
  IdentityKeyPairStructure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IdentityKeyPairStructure_descriptor_,
      IdentityKeyPairStructure::default_instance_,
      IdentityKeyPairStructure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityKeyPairStructure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityKeyPairStructure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IdentityKeyPairStructure));
  SenderKeyStateStructure_descriptor_ = file->message_type(5);
  static const int SenderKeyStateStructure_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure, senderkeyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure, senderchainkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure, sendersigningkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure, sendermessagekeys_),
  };
  SenderKeyStateStructure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SenderKeyStateStructure_descriptor_,
      SenderKeyStateStructure::default_instance_,
      SenderKeyStateStructure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SenderKeyStateStructure));
  SenderKeyStateStructure_SenderChainKey_descriptor_ = SenderKeyStateStructure_descriptor_->nested_type(0);
  static const int SenderKeyStateStructure_SenderChainKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderChainKey, iteration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderChainKey, seed_),
  };
  SenderKeyStateStructure_SenderChainKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SenderKeyStateStructure_SenderChainKey_descriptor_,
      SenderKeyStateStructure_SenderChainKey::default_instance_,
      SenderKeyStateStructure_SenderChainKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderChainKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderChainKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SenderKeyStateStructure_SenderChainKey));
  SenderKeyStateStructure_SenderMessageKey_descriptor_ = SenderKeyStateStructure_descriptor_->nested_type(1);
  static const int SenderKeyStateStructure_SenderMessageKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderMessageKey, iteration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderMessageKey, seed_),
  };
  SenderKeyStateStructure_SenderMessageKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SenderKeyStateStructure_SenderMessageKey_descriptor_,
      SenderKeyStateStructure_SenderMessageKey::default_instance_,
      SenderKeyStateStructure_SenderMessageKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderMessageKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderMessageKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SenderKeyStateStructure_SenderMessageKey));
  SenderKeyStateStructure_SenderSigningKey_descriptor_ = SenderKeyStateStructure_descriptor_->nested_type(2);
  static const int SenderKeyStateStructure_SenderSigningKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderSigningKey, public__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderSigningKey, private__),
  };
  SenderKeyStateStructure_SenderSigningKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SenderKeyStateStructure_SenderSigningKey_descriptor_,
      SenderKeyStateStructure_SenderSigningKey::default_instance_,
      SenderKeyStateStructure_SenderSigningKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderSigningKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyStateStructure_SenderSigningKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SenderKeyStateStructure_SenderSigningKey));
  SenderKeyRecordStructure_descriptor_ = file->message_type(6);
  static const int SenderKeyRecordStructure_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyRecordStructure, senderkeystates_),
  };
  SenderKeyRecordStructure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SenderKeyRecordStructure_descriptor_,
      SenderKeyRecordStructure::default_instance_,
      SenderKeyRecordStructure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyRecordStructure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SenderKeyRecordStructure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SenderKeyRecordStructure));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_protobuf_2fLocalStorageProtocol_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SessionStructure_descriptor_, &SessionStructure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SessionStructure_Chain_descriptor_, &SessionStructure_Chain::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SessionStructure_Chain_ChainKey_descriptor_, &SessionStructure_Chain_ChainKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SessionStructure_Chain_MessageKey_descriptor_, &SessionStructure_Chain_MessageKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SessionStructure_PendingKeyExchange_descriptor_, &SessionStructure_PendingKeyExchange::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SessionStructure_PendingPreKey_descriptor_, &SessionStructure_PendingPreKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RecordStructure_descriptor_, &RecordStructure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PreKeyRecordStructure_descriptor_, &PreKeyRecordStructure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignedPreKeyRecordStructure_descriptor_, &SignedPreKeyRecordStructure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IdentityKeyPairStructure_descriptor_, &IdentityKeyPairStructure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SenderKeyStateStructure_descriptor_, &SenderKeyStateStructure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SenderKeyStateStructure_SenderChainKey_descriptor_, &SenderKeyStateStructure_SenderChainKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SenderKeyStateStructure_SenderMessageKey_descriptor_, &SenderKeyStateStructure_SenderMessageKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SenderKeyStateStructure_SenderSigningKey_descriptor_, &SenderKeyStateStructure_SenderSigningKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SenderKeyRecordStructure_descriptor_, &SenderKeyRecordStructure::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto() {
  delete SessionStructure::default_instance_;
  delete SessionStructure_reflection_;
  delete SessionStructure_Chain::default_instance_;
  delete SessionStructure_Chain_reflection_;
  delete SessionStructure_Chain_ChainKey::default_instance_;
  delete SessionStructure_Chain_ChainKey_reflection_;
  delete SessionStructure_Chain_MessageKey::default_instance_;
  delete SessionStructure_Chain_MessageKey_reflection_;
  delete SessionStructure_PendingKeyExchange::default_instance_;
  delete SessionStructure_PendingKeyExchange_reflection_;
  delete SessionStructure_PendingPreKey::default_instance_;
  delete SessionStructure_PendingPreKey_reflection_;
  delete RecordStructure::default_instance_;
  delete RecordStructure_reflection_;
  delete PreKeyRecordStructure::default_instance_;
  delete PreKeyRecordStructure_reflection_;
  delete SignedPreKeyRecordStructure::default_instance_;
  delete SignedPreKeyRecordStructure_reflection_;
  delete IdentityKeyPairStructure::default_instance_;
  delete IdentityKeyPairStructure_reflection_;
  delete SenderKeyStateStructure::default_instance_;
  delete SenderKeyStateStructure_reflection_;
  delete SenderKeyStateStructure_SenderChainKey::default_instance_;
  delete SenderKeyStateStructure_SenderChainKey_reflection_;
  delete SenderKeyStateStructure_SenderMessageKey::default_instance_;
  delete SenderKeyStateStructure_SenderMessageKey_reflection_;
  delete SenderKeyStateStructure_SenderSigningKey::default_instance_;
  delete SenderKeyStateStructure_SenderSigningKey_reflection_;
  delete SenderKeyRecordStructure::default_instance_;
  delete SenderKeyRecordStructure_reflection_;
}

void protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n#protobuf/LocalStorageProtocol.proto\022\nt"
    "extsecure\"\323\010\n\020SessionStructure\022\026\n\016sessio"
    "nVersion\030\001 \001(\r\022\033\n\023localIdentityPublic\030\002 "
    "\001(\014\022\034\n\024remoteIdentityPublic\030\003 \001(\014\022\017\n\007roo"
    "tKey\030\004 \001(\014\022\027\n\017previousCounter\030\005 \001(\r\0227\n\013s"
    "enderChain\030\006 \001(\0132\".textsecure.SessionStr"
    "ucture.Chain\022:\n\016receiverChains\030\007 \003(\0132\".t"
    "extsecure.SessionStructure.Chain\022K\n\022pend"
    "ingKeyExchange\030\010 \001(\0132/.textsecure.Sessio"
    "nStructure.PendingKeyExchange\022A\n\rpending"
    "PreKey\030\t \001(\0132*.textsecure.SessionStructu"
    "re.PendingPreKey\022\034\n\024remoteRegistrationId"
    "\030\n \001(\r\022\033\n\023localRegistrationId\030\013 \001(\r\022\024\n\014n"
    "eedsRefresh\030\014 \001(\010\022\024\n\014aliceBaseKey\030\r \001(\014\032"
    "\271\002\n\005Chain\022\030\n\020senderRatchetKey\030\001 \001(\014\022\037\n\027s"
    "enderRatchetKeyPrivate\030\002 \001(\014\022=\n\010chainKey"
    "\030\003 \001(\0132+.textsecure.SessionStructure.Cha"
    "in.ChainKey\022B\n\013messageKeys\030\004 \003(\0132-.texts"
    "ecure.SessionStructure.Chain.MessageKey\032"
    "&\n\010ChainKey\022\r\n\005index\030\001 \001(\r\022\013\n\003key\030\002 \001(\014\032"
    "J\n\nMessageKey\022\r\n\005index\030\001 \001(\r\022\021\n\tcipherKe"
    "y\030\002 \001(\014\022\016\n\006macKey\030\003 \001(\014\022\n\n\002iv\030\004 \001(\014\032\315\001\n\022"
    "PendingKeyExchange\022\020\n\010sequence\030\001 \001(\r\022\024\n\014"
    "localBaseKey\030\002 \001(\014\022\033\n\023localBaseKeyPrivat"
    "e\030\003 \001(\014\022\027\n\017localRatchetKey\030\004 \001(\014\022\036\n\026loca"
    "lRatchetKeyPrivate\030\005 \001(\014\022\030\n\020localIdentit"
    "yKey\030\007 \001(\014\022\037\n\027localIdentityKeyPrivate\030\010 "
    "\001(\014\032J\n\rPendingPreKey\022\020\n\010preKeyId\030\001 \001(\r\022\026"
    "\n\016signedPreKeyId\030\003 \001(\005\022\017\n\007baseKey\030\002 \001(\014\""
    "\177\n\017RecordStructure\0224\n\016currentSession\030\001 \001"
    "(\0132\034.textsecure.SessionStructure\0226\n\020prev"
    "iousSessions\030\002 \003(\0132\034.textsecure.SessionS"
    "tructure\"J\n\025PreKeyRecordStructure\022\n\n\002id\030"
    "\001 \001(\r\022\021\n\tpublicKey\030\002 \001(\014\022\022\n\nprivateKey\030\003"
    " \001(\014\"v\n\033SignedPreKeyRecordStructure\022\n\n\002i"
    "d\030\001 \001(\r\022\021\n\tpublicKey\030\002 \001(\014\022\022\n\nprivateKey"
    "\030\003 \001(\014\022\021\n\tsignature\030\004 \001(\014\022\021\n\ttimestamp\030\005"
    " \001(\006\"A\n\030IdentityKeyPairStructure\022\021\n\tpubl"
    "icKey\030\001 \001(\014\022\022\n\nprivateKey\030\002 \001(\014\"\270\003\n\027Send"
    "erKeyStateStructure\022\023\n\013senderKeyId\030\001 \001(\r"
    "\022J\n\016senderChainKey\030\002 \001(\01322.textsecure.Se"
    "nderKeyStateStructure.SenderChainKey\022N\n\020"
    "senderSigningKey\030\003 \001(\01324.textsecure.Send"
    "erKeyStateStructure.SenderSigningKey\022O\n\021"
    "senderMessageKeys\030\004 \003(\01324.textsecure.Sen"
    "derKeyStateStructure.SenderMessageKey\0321\n"
    "\016SenderChainKey\022\021\n\titeration\030\001 \001(\r\022\014\n\004se"
    "ed\030\002 \001(\014\0323\n\020SenderMessageKey\022\021\n\titeratio"
    "n\030\001 \001(\r\022\014\n\004seed\030\002 \001(\014\0323\n\020SenderSigningKe"
    "y\022\016\n\006public\030\001 \001(\014\022\017\n\007private\030\002 \001(\014\"X\n\030Se"
    "nderKeyRecordStructure\022<\n\017senderKeyState"
    "s\030\001 \003(\0132#.textsecure.SenderKeyStateStruc"
    "tureB4\n#org.whispersystems.libaxolotl.st"
    "ateB\rStorageProtos", 2138);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "protobuf/LocalStorageProtocol.proto", &protobuf_RegisterTypes);
  SessionStructure::default_instance_ = new SessionStructure();
  SessionStructure_Chain::default_instance_ = new SessionStructure_Chain();
  SessionStructure_Chain_ChainKey::default_instance_ = new SessionStructure_Chain_ChainKey();
  SessionStructure_Chain_MessageKey::default_instance_ = new SessionStructure_Chain_MessageKey();
  SessionStructure_PendingKeyExchange::default_instance_ = new SessionStructure_PendingKeyExchange();
  SessionStructure_PendingPreKey::default_instance_ = new SessionStructure_PendingPreKey();
  RecordStructure::default_instance_ = new RecordStructure();
  PreKeyRecordStructure::default_instance_ = new PreKeyRecordStructure();
  SignedPreKeyRecordStructure::default_instance_ = new SignedPreKeyRecordStructure();
  IdentityKeyPairStructure::default_instance_ = new IdentityKeyPairStructure();
  SenderKeyStateStructure::default_instance_ = new SenderKeyStateStructure();
  SenderKeyStateStructure_SenderChainKey::default_instance_ = new SenderKeyStateStructure_SenderChainKey();
  SenderKeyStateStructure_SenderMessageKey::default_instance_ = new SenderKeyStateStructure_SenderMessageKey();
  SenderKeyStateStructure_SenderSigningKey::default_instance_ = new SenderKeyStateStructure_SenderSigningKey();
  SenderKeyRecordStructure::default_instance_ = new SenderKeyRecordStructure();
  SessionStructure::default_instance_->InitAsDefaultInstance();
  SessionStructure_Chain::default_instance_->InitAsDefaultInstance();
  SessionStructure_Chain_ChainKey::default_instance_->InitAsDefaultInstance();
  SessionStructure_Chain_MessageKey::default_instance_->InitAsDefaultInstance();
  SessionStructure_PendingKeyExchange::default_instance_->InitAsDefaultInstance();
  SessionStructure_PendingPreKey::default_instance_->InitAsDefaultInstance();
  RecordStructure::default_instance_->InitAsDefaultInstance();
  PreKeyRecordStructure::default_instance_->InitAsDefaultInstance();
  SignedPreKeyRecordStructure::default_instance_->InitAsDefaultInstance();
  IdentityKeyPairStructure::default_instance_->InitAsDefaultInstance();
  SenderKeyStateStructure::default_instance_->InitAsDefaultInstance();
  SenderKeyStateStructure_SenderChainKey::default_instance_->InitAsDefaultInstance();
  SenderKeyStateStructure_SenderMessageKey::default_instance_->InitAsDefaultInstance();
  SenderKeyStateStructure_SenderSigningKey::default_instance_->InitAsDefaultInstance();
  SenderKeyRecordStructure::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_protobuf_2fLocalStorageProtocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_protobuf_2fLocalStorageProtocol_2eproto {
  StaticDescriptorInitializer_protobuf_2fLocalStorageProtocol_2eproto() {
    protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  }
} static_descriptor_initializer_protobuf_2fLocalStorageProtocol_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int SessionStructure_Chain_ChainKey::kIndexFieldNumber;
const int SessionStructure_Chain_ChainKey::kKeyFieldNumber;
#endif  // !_MSC_VER

SessionStructure_Chain_ChainKey::SessionStructure_Chain_ChainKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SessionStructure_Chain_ChainKey::InitAsDefaultInstance() {
}

SessionStructure_Chain_ChainKey::SessionStructure_Chain_ChainKey(const SessionStructure_Chain_ChainKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SessionStructure_Chain_ChainKey::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionStructure_Chain_ChainKey::~SessionStructure_Chain_ChainKey() {
  SharedDtor();
}

void SessionStructure_Chain_ChainKey::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

void SessionStructure_Chain_ChainKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SessionStructure_Chain_ChainKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SessionStructure_Chain_ChainKey_descriptor_;
}

const SessionStructure_Chain_ChainKey& SessionStructure_Chain_ChainKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SessionStructure_Chain_ChainKey* SessionStructure_Chain_ChainKey::default_instance_ = NULL;

SessionStructure_Chain_ChainKey* SessionStructure_Chain_ChainKey::New() const {
  return new SessionStructure_Chain_ChainKey;
}

void SessionStructure_Chain_ChainKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SessionStructure_Chain_ChainKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional bytes key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionStructure_Chain_ChainKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // optional bytes key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SessionStructure_Chain_ChainKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // optional bytes key = 2;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SessionStructure_Chain_ChainKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional bytes key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionStructure_Chain_ChainKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SessionStructure_Chain_ChainKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SessionStructure_Chain_ChainKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SessionStructure_Chain_ChainKey::MergeFrom(const SessionStructure_Chain_ChainKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SessionStructure_Chain_ChainKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SessionStructure_Chain_ChainKey::CopyFrom(const SessionStructure_Chain_ChainKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStructure_Chain_ChainKey::IsInitialized() const {

  return true;
}

void SessionStructure_Chain_ChainKey::Swap(SessionStructure_Chain_ChainKey* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SessionStructure_Chain_ChainKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SessionStructure_Chain_ChainKey_descriptor_;
  metadata.reflection = SessionStructure_Chain_ChainKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SessionStructure_Chain_MessageKey::kIndexFieldNumber;
const int SessionStructure_Chain_MessageKey::kCipherKeyFieldNumber;
const int SessionStructure_Chain_MessageKey::kMacKeyFieldNumber;
const int SessionStructure_Chain_MessageKey::kIvFieldNumber;
#endif  // !_MSC_VER

SessionStructure_Chain_MessageKey::SessionStructure_Chain_MessageKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SessionStructure_Chain_MessageKey::InitAsDefaultInstance() {
}

SessionStructure_Chain_MessageKey::SessionStructure_Chain_MessageKey(const SessionStructure_Chain_MessageKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SessionStructure_Chain_MessageKey::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  cipherkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mackey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionStructure_Chain_MessageKey::~SessionStructure_Chain_MessageKey() {
  SharedDtor();
}

void SessionStructure_Chain_MessageKey::SharedDtor() {
  if (cipherkey_ != &::google::protobuf::internal::kEmptyString) {
    delete cipherkey_;
  }
  if (mackey_ != &::google::protobuf::internal::kEmptyString) {
    delete mackey_;
  }
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (this != default_instance_) {
  }
}

void SessionStructure_Chain_MessageKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SessionStructure_Chain_MessageKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SessionStructure_Chain_MessageKey_descriptor_;
}

const SessionStructure_Chain_MessageKey& SessionStructure_Chain_MessageKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SessionStructure_Chain_MessageKey* SessionStructure_Chain_MessageKey::default_instance_ = NULL;

SessionStructure_Chain_MessageKey* SessionStructure_Chain_MessageKey::New() const {
  return new SessionStructure_Chain_MessageKey;
}

void SessionStructure_Chain_MessageKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    if (has_cipherkey()) {
      if (cipherkey_ != &::google::protobuf::internal::kEmptyString) {
        cipherkey_->clear();
      }
    }
    if (has_mackey()) {
      if (mackey_ != &::google::protobuf::internal::kEmptyString) {
        mackey_->clear();
      }
    }
    if (has_iv()) {
      if (iv_ != &::google::protobuf::internal::kEmptyString) {
        iv_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SessionStructure_Chain_MessageKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cipherKey;
        break;
      }

      // optional bytes cipherKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cipherKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_cipherkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_macKey;
        break;
      }

      // optional bytes macKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_macKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mackey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_iv;
        break;
      }

      // optional bytes iv = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionStructure_Chain_MessageKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // optional bytes cipherKey = 2;
  if (has_cipherkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->cipherkey(), output);
  }

  // optional bytes macKey = 3;
  if (has_mackey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->mackey(), output);
  }

  // optional bytes iv = 4;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->iv(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SessionStructure_Chain_MessageKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // optional bytes cipherKey = 2;
  if (has_cipherkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->cipherkey(), target);
  }

  // optional bytes macKey = 3;
  if (has_mackey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->mackey(), target);
  }

  // optional bytes iv = 4;
  if (has_iv()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->iv(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SessionStructure_Chain_MessageKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional bytes cipherKey = 2;
    if (has_cipherkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->cipherkey());
    }

    // optional bytes macKey = 3;
    if (has_mackey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mackey());
    }

    // optional bytes iv = 4;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionStructure_Chain_MessageKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SessionStructure_Chain_MessageKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SessionStructure_Chain_MessageKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SessionStructure_Chain_MessageKey::MergeFrom(const SessionStructure_Chain_MessageKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_cipherkey()) {
      set_cipherkey(from.cipherkey());
    }
    if (from.has_mackey()) {
      set_mackey(from.mackey());
    }
    if (from.has_iv()) {
      set_iv(from.iv());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SessionStructure_Chain_MessageKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SessionStructure_Chain_MessageKey::CopyFrom(const SessionStructure_Chain_MessageKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStructure_Chain_MessageKey::IsInitialized() const {

  return true;
}

void SessionStructure_Chain_MessageKey::Swap(SessionStructure_Chain_MessageKey* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(cipherkey_, other->cipherkey_);
    std::swap(mackey_, other->mackey_);
    std::swap(iv_, other->iv_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SessionStructure_Chain_MessageKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SessionStructure_Chain_MessageKey_descriptor_;
  metadata.reflection = SessionStructure_Chain_MessageKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SessionStructure_Chain::kSenderRatchetKeyFieldNumber;
const int SessionStructure_Chain::kSenderRatchetKeyPrivateFieldNumber;
const int SessionStructure_Chain::kChainKeyFieldNumber;
const int SessionStructure_Chain::kMessageKeysFieldNumber;
#endif  // !_MSC_VER

SessionStructure_Chain::SessionStructure_Chain()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SessionStructure_Chain::InitAsDefaultInstance() {
  chainkey_ = const_cast< ::textsecure::SessionStructure_Chain_ChainKey*>(&::textsecure::SessionStructure_Chain_ChainKey::default_instance());
}

SessionStructure_Chain::SessionStructure_Chain(const SessionStructure_Chain& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SessionStructure_Chain::SharedCtor() {
  _cached_size_ = 0;
  senderratchetkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  senderratchetkeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  chainkey_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionStructure_Chain::~SessionStructure_Chain() {
  SharedDtor();
}

void SessionStructure_Chain::SharedDtor() {
  if (senderratchetkey_ != &::google::protobuf::internal::kEmptyString) {
    delete senderratchetkey_;
  }
  if (senderratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete senderratchetkeyprivate_;
  }
  if (this != default_instance_) {
    delete chainkey_;
  }
}

void SessionStructure_Chain::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SessionStructure_Chain::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SessionStructure_Chain_descriptor_;
}

const SessionStructure_Chain& SessionStructure_Chain::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SessionStructure_Chain* SessionStructure_Chain::default_instance_ = NULL;

SessionStructure_Chain* SessionStructure_Chain::New() const {
  return new SessionStructure_Chain;
}

void SessionStructure_Chain::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_senderratchetkey()) {
      if (senderratchetkey_ != &::google::protobuf::internal::kEmptyString) {
        senderratchetkey_->clear();
      }
    }
    if (has_senderratchetkeyprivate()) {
      if (senderratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
        senderratchetkeyprivate_->clear();
      }
    }
    if (has_chainkey()) {
      if (chainkey_ != NULL) chainkey_->::textsecure::SessionStructure_Chain_ChainKey::Clear();
    }
  }
  messagekeys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SessionStructure_Chain::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes senderRatchetKey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_senderratchetkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_senderRatchetKeyPrivate;
        break;
      }

      // optional bytes senderRatchetKeyPrivate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_senderRatchetKeyPrivate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_senderratchetkeyprivate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_chainKey;
        break;
      }

      // optional .textsecure.SessionStructure.Chain.ChainKey chainKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chainKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_chainkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_messageKeys;
        break;
      }

      // repeated .textsecure.SessionStructure.Chain.MessageKey messageKeys = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_messageKeys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_messagekeys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_messageKeys;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionStructure_Chain::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes senderRatchetKey = 1;
  if (has_senderratchetkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->senderratchetkey(), output);
  }

  // optional bytes senderRatchetKeyPrivate = 2;
  if (has_senderratchetkeyprivate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->senderratchetkeyprivate(), output);
  }

  // optional .textsecure.SessionStructure.Chain.ChainKey chainKey = 3;
  if (has_chainkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->chainkey(), output);
  }

  // repeated .textsecure.SessionStructure.Chain.MessageKey messageKeys = 4;
  for (int i = 0; i < this->messagekeys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->messagekeys(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SessionStructure_Chain::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes senderRatchetKey = 1;
  if (has_senderratchetkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->senderratchetkey(), target);
  }

  // optional bytes senderRatchetKeyPrivate = 2;
  if (has_senderratchetkeyprivate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->senderratchetkeyprivate(), target);
  }

  // optional .textsecure.SessionStructure.Chain.ChainKey chainKey = 3;
  if (has_chainkey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->chainkey(), target);
  }

  // repeated .textsecure.SessionStructure.Chain.MessageKey messageKeys = 4;
  for (int i = 0; i < this->messagekeys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->messagekeys(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SessionStructure_Chain::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes senderRatchetKey = 1;
    if (has_senderratchetkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->senderratchetkey());
    }

    // optional bytes senderRatchetKeyPrivate = 2;
    if (has_senderratchetkeyprivate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->senderratchetkeyprivate());
    }

    // optional .textsecure.SessionStructure.Chain.ChainKey chainKey = 3;
    if (has_chainkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->chainkey());
    }

  }
  // repeated .textsecure.SessionStructure.Chain.MessageKey messageKeys = 4;
  total_size += 1 * this->messagekeys_size();
  for (int i = 0; i < this->messagekeys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->messagekeys(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionStructure_Chain::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SessionStructure_Chain* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SessionStructure_Chain*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SessionStructure_Chain::MergeFrom(const SessionStructure_Chain& from) {
  GOOGLE_CHECK_NE(&from, this);
  messagekeys_.MergeFrom(from.messagekeys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_senderratchetkey()) {
      set_senderratchetkey(from.senderratchetkey());
    }
    if (from.has_senderratchetkeyprivate()) {
      set_senderratchetkeyprivate(from.senderratchetkeyprivate());
    }
    if (from.has_chainkey()) {
      mutable_chainkey()->::textsecure::SessionStructure_Chain_ChainKey::MergeFrom(from.chainkey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SessionStructure_Chain::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SessionStructure_Chain::CopyFrom(const SessionStructure_Chain& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStructure_Chain::IsInitialized() const {

  return true;
}

void SessionStructure_Chain::Swap(SessionStructure_Chain* other) {
  if (other != this) {
    std::swap(senderratchetkey_, other->senderratchetkey_);
    std::swap(senderratchetkeyprivate_, other->senderratchetkeyprivate_);
    std::swap(chainkey_, other->chainkey_);
    messagekeys_.Swap(&other->messagekeys_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SessionStructure_Chain::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SessionStructure_Chain_descriptor_;
  metadata.reflection = SessionStructure_Chain_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SessionStructure_PendingKeyExchange::kSequenceFieldNumber;
const int SessionStructure_PendingKeyExchange::kLocalBaseKeyFieldNumber;
const int SessionStructure_PendingKeyExchange::kLocalBaseKeyPrivateFieldNumber;
const int SessionStructure_PendingKeyExchange::kLocalRatchetKeyFieldNumber;
const int SessionStructure_PendingKeyExchange::kLocalRatchetKeyPrivateFieldNumber;
const int SessionStructure_PendingKeyExchange::kLocalIdentityKeyFieldNumber;
const int SessionStructure_PendingKeyExchange::kLocalIdentityKeyPrivateFieldNumber;
#endif  // !_MSC_VER

SessionStructure_PendingKeyExchange::SessionStructure_PendingKeyExchange()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SessionStructure_PendingKeyExchange::InitAsDefaultInstance() {
}

SessionStructure_PendingKeyExchange::SessionStructure_PendingKeyExchange(const SessionStructure_PendingKeyExchange& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SessionStructure_PendingKeyExchange::SharedCtor() {
  _cached_size_ = 0;
  sequence_ = 0u;
  localbasekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  localbasekeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  localratchetkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  localratchetkeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  localidentitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  localidentitykeyprivate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionStructure_PendingKeyExchange::~SessionStructure_PendingKeyExchange() {
  SharedDtor();
}

void SessionStructure_PendingKeyExchange::SharedDtor() {
  if (localbasekey_ != &::google::protobuf::internal::kEmptyString) {
    delete localbasekey_;
  }
  if (localbasekeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete localbasekeyprivate_;
  }
  if (localratchetkey_ != &::google::protobuf::internal::kEmptyString) {
    delete localratchetkey_;
  }
  if (localratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete localratchetkeyprivate_;
  }
  if (localidentitykey_ != &::google::protobuf::internal::kEmptyString) {
    delete localidentitykey_;
  }
  if (localidentitykeyprivate_ != &::google::protobuf::internal::kEmptyString) {
    delete localidentitykeyprivate_;
  }
  if (this != default_instance_) {
  }
}

void SessionStructure_PendingKeyExchange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SessionStructure_PendingKeyExchange::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SessionStructure_PendingKeyExchange_descriptor_;
}

const SessionStructure_PendingKeyExchange& SessionStructure_PendingKeyExchange::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SessionStructure_PendingKeyExchange* SessionStructure_PendingKeyExchange::default_instance_ = NULL;

SessionStructure_PendingKeyExchange* SessionStructure_PendingKeyExchange::New() const {
  return new SessionStructure_PendingKeyExchange;
}

void SessionStructure_PendingKeyExchange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sequence_ = 0u;
    if (has_localbasekey()) {
      if (localbasekey_ != &::google::protobuf::internal::kEmptyString) {
        localbasekey_->clear();
      }
    }
    if (has_localbasekeyprivate()) {
      if (localbasekeyprivate_ != &::google::protobuf::internal::kEmptyString) {
        localbasekeyprivate_->clear();
      }
    }
    if (has_localratchetkey()) {
      if (localratchetkey_ != &::google::protobuf::internal::kEmptyString) {
        localratchetkey_->clear();
      }
    }
    if (has_localratchetkeyprivate()) {
      if (localratchetkeyprivate_ != &::google::protobuf::internal::kEmptyString) {
        localratchetkeyprivate_->clear();
      }
    }
    if (has_localidentitykey()) {
      if (localidentitykey_ != &::google::protobuf::internal::kEmptyString) {
        localidentitykey_->clear();
      }
    }
    if (has_localidentitykeyprivate()) {
      if (localidentitykeyprivate_ != &::google::protobuf::internal::kEmptyString) {
        localidentitykeyprivate_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SessionStructure_PendingKeyExchange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sequence = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_localBaseKey;
        break;
      }

      // optional bytes localBaseKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localBaseKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_localbasekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_localBaseKeyPrivate;
        break;
      }

      // optional bytes localBaseKeyPrivate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localBaseKeyPrivate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_localbasekeyprivate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_localRatchetKey;
        break;
      }

      // optional bytes localRatchetKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localRatchetKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_localratchetkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_localRatchetKeyPrivate;
        break;
      }

      // optional bytes localRatchetKeyPrivate = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localRatchetKeyPrivate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_localratchetkeyprivate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_localIdentityKey;
        break;
      }

      // optional bytes localIdentityKey = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localIdentityKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_localidentitykey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_localIdentityKeyPrivate;
        break;
      }

      // optional bytes localIdentityKeyPrivate = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localIdentityKeyPrivate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_localidentitykeyprivate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionStructure_PendingKeyExchange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 sequence = 1;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sequence(), output);
  }

  // optional bytes localBaseKey = 2;
  if (has_localbasekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->localbasekey(), output);
  }

  // optional bytes localBaseKeyPrivate = 3;
  if (has_localbasekeyprivate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->localbasekeyprivate(), output);
  }

  // optional bytes localRatchetKey = 4;
  if (has_localratchetkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->localratchetkey(), output);
  }

  // optional bytes localRatchetKeyPrivate = 5;
  if (has_localratchetkeyprivate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->localratchetkeyprivate(), output);
  }

  // optional bytes localIdentityKey = 7;
  if (has_localidentitykey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->localidentitykey(), output);
  }

  // optional bytes localIdentityKeyPrivate = 8;
  if (has_localidentitykeyprivate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->localidentitykeyprivate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SessionStructure_PendingKeyExchange::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 sequence = 1;
  if (has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sequence(), target);
  }

  // optional bytes localBaseKey = 2;
  if (has_localbasekey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->localbasekey(), target);
  }

  // optional bytes localBaseKeyPrivate = 3;
  if (has_localbasekeyprivate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->localbasekeyprivate(), target);
  }

  // optional bytes localRatchetKey = 4;
  if (has_localratchetkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->localratchetkey(), target);
  }

  // optional bytes localRatchetKeyPrivate = 5;
  if (has_localratchetkeyprivate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->localratchetkeyprivate(), target);
  }

  // optional bytes localIdentityKey = 7;
  if (has_localidentitykey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->localidentitykey(), target);
  }

  // optional bytes localIdentityKeyPrivate = 8;
  if (has_localidentitykeyprivate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->localidentitykeyprivate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SessionStructure_PendingKeyExchange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sequence = 1;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence());
    }

    // optional bytes localBaseKey = 2;
    if (has_localbasekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->localbasekey());
    }

    // optional bytes localBaseKeyPrivate = 3;
    if (has_localbasekeyprivate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->localbasekeyprivate());
    }

    // optional bytes localRatchetKey = 4;
    if (has_localratchetkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->localratchetkey());
    }

    // optional bytes localRatchetKeyPrivate = 5;
    if (has_localratchetkeyprivate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->localratchetkeyprivate());
    }

    // optional bytes localIdentityKey = 7;
    if (has_localidentitykey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->localidentitykey());
    }

    // optional bytes localIdentityKeyPrivate = 8;
    if (has_localidentitykeyprivate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->localidentitykeyprivate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionStructure_PendingKeyExchange::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SessionStructure_PendingKeyExchange* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SessionStructure_PendingKeyExchange*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SessionStructure_PendingKeyExchange::MergeFrom(const SessionStructure_PendingKeyExchange& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
    if (from.has_localbasekey()) {
      set_localbasekey(from.localbasekey());
    }
    if (from.has_localbasekeyprivate()) {
      set_localbasekeyprivate(from.localbasekeyprivate());
    }
    if (from.has_localratchetkey()) {
      set_localratchetkey(from.localratchetkey());
    }
    if (from.has_localratchetkeyprivate()) {
      set_localratchetkeyprivate(from.localratchetkeyprivate());
    }
    if (from.has_localidentitykey()) {
      set_localidentitykey(from.localidentitykey());
    }
    if (from.has_localidentitykeyprivate()) {
      set_localidentitykeyprivate(from.localidentitykeyprivate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SessionStructure_PendingKeyExchange::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SessionStructure_PendingKeyExchange::CopyFrom(const SessionStructure_PendingKeyExchange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStructure_PendingKeyExchange::IsInitialized() const {

  return true;
}

void SessionStructure_PendingKeyExchange::Swap(SessionStructure_PendingKeyExchange* other) {
  if (other != this) {
    std::swap(sequence_, other->sequence_);
    std::swap(localbasekey_, other->localbasekey_);
    std::swap(localbasekeyprivate_, other->localbasekeyprivate_);
    std::swap(localratchetkey_, other->localratchetkey_);
    std::swap(localratchetkeyprivate_, other->localratchetkeyprivate_);
    std::swap(localidentitykey_, other->localidentitykey_);
    std::swap(localidentitykeyprivate_, other->localidentitykeyprivate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SessionStructure_PendingKeyExchange::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SessionStructure_PendingKeyExchange_descriptor_;
  metadata.reflection = SessionStructure_PendingKeyExchange_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SessionStructure_PendingPreKey::kPreKeyIdFieldNumber;
const int SessionStructure_PendingPreKey::kSignedPreKeyIdFieldNumber;
const int SessionStructure_PendingPreKey::kBaseKeyFieldNumber;
#endif  // !_MSC_VER

SessionStructure_PendingPreKey::SessionStructure_PendingPreKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SessionStructure_PendingPreKey::InitAsDefaultInstance() {
}

SessionStructure_PendingPreKey::SessionStructure_PendingPreKey(const SessionStructure_PendingPreKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SessionStructure_PendingPreKey::SharedCtor() {
  _cached_size_ = 0;
  prekeyid_ = 0u;
  signedprekeyid_ = 0;
  basekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionStructure_PendingPreKey::~SessionStructure_PendingPreKey() {
  SharedDtor();
}

void SessionStructure_PendingPreKey::SharedDtor() {
  if (basekey_ != &::google::protobuf::internal::kEmptyString) {
    delete basekey_;
  }
  if (this != default_instance_) {
  }
}

void SessionStructure_PendingPreKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SessionStructure_PendingPreKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SessionStructure_PendingPreKey_descriptor_;
}

const SessionStructure_PendingPreKey& SessionStructure_PendingPreKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SessionStructure_PendingPreKey* SessionStructure_PendingPreKey::default_instance_ = NULL;

SessionStructure_PendingPreKey* SessionStructure_PendingPreKey::New() const {
  return new SessionStructure_PendingPreKey;
}

void SessionStructure_PendingPreKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    prekeyid_ = 0u;
    signedprekeyid_ = 0;
    if (has_basekey()) {
      if (basekey_ != &::google::protobuf::internal::kEmptyString) {
        basekey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SessionStructure_PendingPreKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 preKeyId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prekeyid_)));
          set_has_prekeyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_baseKey;
        break;
      }

      // optional bytes baseKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_baseKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_basekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_signedPreKeyId;
        break;
      }

      // optional int32 signedPreKeyId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_signedPreKeyId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signedprekeyid_)));
          set_has_signedprekeyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionStructure_PendingPreKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 preKeyId = 1;
  if (has_prekeyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->prekeyid(), output);
  }

  // optional bytes baseKey = 2;
  if (has_basekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->basekey(), output);
  }

  // optional int32 signedPreKeyId = 3;
  if (has_signedprekeyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->signedprekeyid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SessionStructure_PendingPreKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 preKeyId = 1;
  if (has_prekeyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->prekeyid(), target);
  }

  // optional bytes baseKey = 2;
  if (has_basekey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->basekey(), target);
  }

  // optional int32 signedPreKeyId = 3;
  if (has_signedprekeyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->signedprekeyid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SessionStructure_PendingPreKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 preKeyId = 1;
    if (has_prekeyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prekeyid());
    }

    // optional int32 signedPreKeyId = 3;
    if (has_signedprekeyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->signedprekeyid());
    }

    // optional bytes baseKey = 2;
    if (has_basekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->basekey());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionStructure_PendingPreKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SessionStructure_PendingPreKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SessionStructure_PendingPreKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SessionStructure_PendingPreKey::MergeFrom(const SessionStructure_PendingPreKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_prekeyid()) {
      set_prekeyid(from.prekeyid());
    }
    if (from.has_signedprekeyid()) {
      set_signedprekeyid(from.signedprekeyid());
    }
    if (from.has_basekey()) {
      set_basekey(from.basekey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SessionStructure_PendingPreKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SessionStructure_PendingPreKey::CopyFrom(const SessionStructure_PendingPreKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStructure_PendingPreKey::IsInitialized() const {

  return true;
}

void SessionStructure_PendingPreKey::Swap(SessionStructure_PendingPreKey* other) {
  if (other != this) {
    std::swap(prekeyid_, other->prekeyid_);
    std::swap(signedprekeyid_, other->signedprekeyid_);
    std::swap(basekey_, other->basekey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SessionStructure_PendingPreKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SessionStructure_PendingPreKey_descriptor_;
  metadata.reflection = SessionStructure_PendingPreKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SessionStructure::kSessionVersionFieldNumber;
const int SessionStructure::kLocalIdentityPublicFieldNumber;
const int SessionStructure::kRemoteIdentityPublicFieldNumber;
const int SessionStructure::kRootKeyFieldNumber;
const int SessionStructure::kPreviousCounterFieldNumber;
const int SessionStructure::kSenderChainFieldNumber;
const int SessionStructure::kReceiverChainsFieldNumber;
const int SessionStructure::kPendingKeyExchangeFieldNumber;
const int SessionStructure::kPendingPreKeyFieldNumber;
const int SessionStructure::kRemoteRegistrationIdFieldNumber;
const int SessionStructure::kLocalRegistrationIdFieldNumber;
const int SessionStructure::kNeedsRefreshFieldNumber;
const int SessionStructure::kAliceBaseKeyFieldNumber;
#endif  // !_MSC_VER

SessionStructure::SessionStructure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SessionStructure::InitAsDefaultInstance() {
  senderchain_ = const_cast< ::textsecure::SessionStructure_Chain*>(&::textsecure::SessionStructure_Chain::default_instance());
  pendingkeyexchange_ = const_cast< ::textsecure::SessionStructure_PendingKeyExchange*>(&::textsecure::SessionStructure_PendingKeyExchange::default_instance());
  pendingprekey_ = const_cast< ::textsecure::SessionStructure_PendingPreKey*>(&::textsecure::SessionStructure_PendingPreKey::default_instance());
}

SessionStructure::SessionStructure(const SessionStructure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SessionStructure::SharedCtor() {
  _cached_size_ = 0;
  sessionversion_ = 0u;
  localidentitypublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  remoteidentitypublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  rootkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  previouscounter_ = 0u;
  senderchain_ = NULL;
  pendingkeyexchange_ = NULL;
  pendingprekey_ = NULL;
  remoteregistrationid_ = 0u;
  localregistrationid_ = 0u;
  needsrefresh_ = false;
  alicebasekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionStructure::~SessionStructure() {
  SharedDtor();
}

void SessionStructure::SharedDtor() {
  if (localidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
    delete localidentitypublic_;
  }
  if (remoteidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
    delete remoteidentitypublic_;
  }
  if (rootkey_ != &::google::protobuf::internal::kEmptyString) {
    delete rootkey_;
  }
  if (alicebasekey_ != &::google::protobuf::internal::kEmptyString) {
    delete alicebasekey_;
  }
  if (this != default_instance_) {
    delete senderchain_;
    delete pendingkeyexchange_;
    delete pendingprekey_;
  }
}

void SessionStructure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SessionStructure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SessionStructure_descriptor_;
}

const SessionStructure& SessionStructure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SessionStructure* SessionStructure::default_instance_ = NULL;

SessionStructure* SessionStructure::New() const {
  return new SessionStructure;
}

void SessionStructure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sessionversion_ = 0u;
    if (has_localidentitypublic()) {
      if (localidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
        localidentitypublic_->clear();
      }
    }
    if (has_remoteidentitypublic()) {
      if (remoteidentitypublic_ != &::google::protobuf::internal::kEmptyString) {
        remoteidentitypublic_->clear();
      }
    }
    if (has_rootkey()) {
      if (rootkey_ != &::google::protobuf::internal::kEmptyString) {
        rootkey_->clear();
      }
    }
    previouscounter_ = 0u;
    if (has_senderchain()) {
      if (senderchain_ != NULL) senderchain_->::textsecure::SessionStructure_Chain::Clear();
    }
    if (has_pendingkeyexchange()) {
      if (pendingkeyexchange_ != NULL) pendingkeyexchange_->::textsecure::SessionStructure_PendingKeyExchange::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_pendingprekey()) {
      if (pendingprekey_ != NULL) pendingprekey_->::textsecure::SessionStructure_PendingPreKey::Clear();
    }
    remoteregistrationid_ = 0u;
    localregistrationid_ = 0u;
    needsrefresh_ = false;
    if (has_alicebasekey()) {
      if (alicebasekey_ != &::google::protobuf::internal::kEmptyString) {
        alicebasekey_->clear();
      }
    }
  }
  receiverchains_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SessionStructure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sessionVersion = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sessionversion_)));
          set_has_sessionversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_localIdentityPublic;
        break;
      }

      // optional bytes localIdentityPublic = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_localIdentityPublic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_localidentitypublic()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_remoteIdentityPublic;
        break;
      }

      // optional bytes remoteIdentityPublic = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_remoteIdentityPublic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_remoteidentitypublic()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_rootKey;
        break;
      }

      // optional bytes rootKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rootKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_rootkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_previousCounter;
        break;
      }

      // optional uint32 previousCounter = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_previousCounter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &previouscounter_)));
          set_has_previouscounter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_senderChain;
        break;
      }

      // optional .textsecure.SessionStructure.Chain senderChain = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_senderChain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_senderchain()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_receiverChains;
        break;
      }

      // repeated .textsecure.SessionStructure.Chain receiverChains = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_receiverChains:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_receiverchains()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_receiverChains;
        if (input->ExpectTag(66)) goto parse_pendingKeyExchange;
        break;
      }

      // optional .textsecure.SessionStructure.PendingKeyExchange pendingKeyExchange = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pendingKeyExchange:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pendingkeyexchange()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_pendingPreKey;
        break;
      }

      // optional .textsecure.SessionStructure.PendingPreKey pendingPreKey = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pendingPreKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pendingprekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_remoteRegistrationId;
        break;
      }

      // optional uint32 remoteRegistrationId = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remoteRegistrationId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remoteregistrationid_)));
          set_has_remoteregistrationid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_localRegistrationId;
        break;
      }

      // optional uint32 localRegistrationId = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_localRegistrationId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &localregistrationid_)));
          set_has_localregistrationid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_needsRefresh;
        break;
      }

      // optional bool needsRefresh = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_needsRefresh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &needsrefresh_)));
          set_has_needsrefresh();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_aliceBaseKey;
        break;
      }

      // optional bytes aliceBaseKey = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aliceBaseKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_alicebasekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SessionStructure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 sessionVersion = 1;
  if (has_sessionversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sessionversion(), output);
  }

  // optional bytes localIdentityPublic = 2;
  if (has_localidentitypublic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->localidentitypublic(), output);
  }

  // optional bytes remoteIdentityPublic = 3;
  if (has_remoteidentitypublic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->remoteidentitypublic(), output);
  }

  // optional bytes rootKey = 4;
  if (has_rootkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->rootkey(), output);
  }

  // optional uint32 previousCounter = 5;
  if (has_previouscounter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->previouscounter(), output);
  }

  // optional .textsecure.SessionStructure.Chain senderChain = 6;
  if (has_senderchain()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->senderchain(), output);
  }

  // repeated .textsecure.SessionStructure.Chain receiverChains = 7;
  for (int i = 0; i < this->receiverchains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->receiverchains(i), output);
  }

  // optional .textsecure.SessionStructure.PendingKeyExchange pendingKeyExchange = 8;
  if (has_pendingkeyexchange()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->pendingkeyexchange(), output);
  }

  // optional .textsecure.SessionStructure.PendingPreKey pendingPreKey = 9;
  if (has_pendingprekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->pendingprekey(), output);
  }

  // optional uint32 remoteRegistrationId = 10;
  if (has_remoteregistrationid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->remoteregistrationid(), output);
  }

  // optional uint32 localRegistrationId = 11;
  if (has_localregistrationid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->localregistrationid(), output);
  }

  // optional bool needsRefresh = 12;
  if (has_needsrefresh()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->needsrefresh(), output);
  }

  // optional bytes aliceBaseKey = 13;
  if (has_alicebasekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      13, this->alicebasekey(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SessionStructure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 sessionVersion = 1;
  if (has_sessionversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sessionversion(), target);
  }

  // optional bytes localIdentityPublic = 2;
  if (has_localidentitypublic()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->localidentitypublic(), target);
  }

  // optional bytes remoteIdentityPublic = 3;
  if (has_remoteidentitypublic()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->remoteidentitypublic(), target);
  }

  // optional bytes rootKey = 4;
  if (has_rootkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->rootkey(), target);
  }

  // optional uint32 previousCounter = 5;
  if (has_previouscounter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->previouscounter(), target);
  }

  // optional .textsecure.SessionStructure.Chain senderChain = 6;
  if (has_senderchain()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->senderchain(), target);
  }

  // repeated .textsecure.SessionStructure.Chain receiverChains = 7;
  for (int i = 0; i < this->receiverchains_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->receiverchains(i), target);
  }

  // optional .textsecure.SessionStructure.PendingKeyExchange pendingKeyExchange = 8;
  if (has_pendingkeyexchange()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->pendingkeyexchange(), target);
  }

  // optional .textsecure.SessionStructure.PendingPreKey pendingPreKey = 9;
  if (has_pendingprekey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->pendingprekey(), target);
  }

  // optional uint32 remoteRegistrationId = 10;
  if (has_remoteregistrationid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->remoteregistrationid(), target);
  }

  // optional uint32 localRegistrationId = 11;
  if (has_localregistrationid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->localregistrationid(), target);
  }

  // optional bool needsRefresh = 12;
  if (has_needsrefresh()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->needsrefresh(), target);
  }

  // optional bytes aliceBaseKey = 13;
  if (has_alicebasekey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        13, this->alicebasekey(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SessionStructure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sessionVersion = 1;
    if (has_sessionversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sessionversion());
    }

    // optional bytes localIdentityPublic = 2;
    if (has_localidentitypublic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->localidentitypublic());
    }

    // optional bytes remoteIdentityPublic = 3;
    if (has_remoteidentitypublic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->remoteidentitypublic());
    }

    // optional bytes rootKey = 4;
    if (has_rootkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->rootkey());
    }

    // optional uint32 previousCounter = 5;
    if (has_previouscounter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->previouscounter());
    }

    // optional .textsecure.SessionStructure.Chain senderChain = 6;
    if (has_senderchain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->senderchain());
    }

    // optional .textsecure.SessionStructure.PendingKeyExchange pendingKeyExchange = 8;
    if (has_pendingkeyexchange()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pendingkeyexchange());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .textsecure.SessionStructure.PendingPreKey pendingPreKey = 9;
    if (has_pendingprekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pendingprekey());
    }

    // optional uint32 remoteRegistrationId = 10;
    if (has_remoteregistrationid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remoteregistrationid());
    }

    // optional uint32 localRegistrationId = 11;
    if (has_localregistrationid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->localregistrationid());
    }

    // optional bool needsRefresh = 12;
    if (has_needsrefresh()) {
      total_size += 1 + 1;
    }

    // optional bytes aliceBaseKey = 13;
    if (has_alicebasekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->alicebasekey());
    }

  }
  // repeated .textsecure.SessionStructure.Chain receiverChains = 7;
  total_size += 1 * this->receiverchains_size();
  for (int i = 0; i < this->receiverchains_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->receiverchains(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionStructure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SessionStructure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SessionStructure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SessionStructure::MergeFrom(const SessionStructure& from) {
  GOOGLE_CHECK_NE(&from, this);
  receiverchains_.MergeFrom(from.receiverchains_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sessionversion()) {
      set_sessionversion(from.sessionversion());
    }
    if (from.has_localidentitypublic()) {
      set_localidentitypublic(from.localidentitypublic());
    }
    if (from.has_remoteidentitypublic()) {
      set_remoteidentitypublic(from.remoteidentitypublic());
    }
    if (from.has_rootkey()) {
      set_rootkey(from.rootkey());
    }
    if (from.has_previouscounter()) {
      set_previouscounter(from.previouscounter());
    }
    if (from.has_senderchain()) {
      mutable_senderchain()->::textsecure::SessionStructure_Chain::MergeFrom(from.senderchain());
    }
    if (from.has_pendingkeyexchange()) {
      mutable_pendingkeyexchange()->::textsecure::SessionStructure_PendingKeyExchange::MergeFrom(from.pendingkeyexchange());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_pendingprekey()) {
      mutable_pendingprekey()->::textsecure::SessionStructure_PendingPreKey::MergeFrom(from.pendingprekey());
    }
    if (from.has_remoteregistrationid()) {
      set_remoteregistrationid(from.remoteregistrationid());
    }
    if (from.has_localregistrationid()) {
      set_localregistrationid(from.localregistrationid());
    }
    if (from.has_needsrefresh()) {
      set_needsrefresh(from.needsrefresh());
    }
    if (from.has_alicebasekey()) {
      set_alicebasekey(from.alicebasekey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SessionStructure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SessionStructure::CopyFrom(const SessionStructure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStructure::IsInitialized() const {

  return true;
}

void SessionStructure::Swap(SessionStructure* other) {
  if (other != this) {
    std::swap(sessionversion_, other->sessionversion_);
    std::swap(localidentitypublic_, other->localidentitypublic_);
    std::swap(remoteidentitypublic_, other->remoteidentitypublic_);
    std::swap(rootkey_, other->rootkey_);
    std::swap(previouscounter_, other->previouscounter_);
    std::swap(senderchain_, other->senderchain_);
    receiverchains_.Swap(&other->receiverchains_);
    std::swap(pendingkeyexchange_, other->pendingkeyexchange_);
    std::swap(pendingprekey_, other->pendingprekey_);
    std::swap(remoteregistrationid_, other->remoteregistrationid_);
    std::swap(localregistrationid_, other->localregistrationid_);
    std::swap(needsrefresh_, other->needsrefresh_);
    std::swap(alicebasekey_, other->alicebasekey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SessionStructure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SessionStructure_descriptor_;
  metadata.reflection = SessionStructure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RecordStructure::kCurrentSessionFieldNumber;
const int RecordStructure::kPreviousSessionsFieldNumber;
#endif  // !_MSC_VER

RecordStructure::RecordStructure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RecordStructure::InitAsDefaultInstance() {
  currentsession_ = const_cast< ::textsecure::SessionStructure*>(&::textsecure::SessionStructure::default_instance());
}

RecordStructure::RecordStructure(const RecordStructure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RecordStructure::SharedCtor() {
  _cached_size_ = 0;
  currentsession_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecordStructure::~RecordStructure() {
  SharedDtor();
}

void RecordStructure::SharedDtor() {
  if (this != default_instance_) {
    delete currentsession_;
  }
}

void RecordStructure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RecordStructure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RecordStructure_descriptor_;
}

const RecordStructure& RecordStructure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

RecordStructure* RecordStructure::default_instance_ = NULL;

RecordStructure* RecordStructure::New() const {
  return new RecordStructure;
}

void RecordStructure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_currentsession()) {
      if (currentsession_ != NULL) currentsession_->::textsecure::SessionStructure::Clear();
    }
  }
  previoussessions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RecordStructure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .textsecure.SessionStructure currentSession = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_currentsession()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_previousSessions;
        break;
      }

      // repeated .textsecure.SessionStructure previousSessions = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_previousSessions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_previoussessions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_previousSessions;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RecordStructure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .textsecure.SessionStructure currentSession = 1;
  if (has_currentsession()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->currentsession(), output);
  }

  // repeated .textsecure.SessionStructure previousSessions = 2;
  for (int i = 0; i < this->previoussessions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->previoussessions(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RecordStructure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .textsecure.SessionStructure currentSession = 1;
  if (has_currentsession()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->currentsession(), target);
  }

  // repeated .textsecure.SessionStructure previousSessions = 2;
  for (int i = 0; i < this->previoussessions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->previoussessions(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RecordStructure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .textsecure.SessionStructure currentSession = 1;
    if (has_currentsession()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->currentsession());
    }

  }
  // repeated .textsecure.SessionStructure previousSessions = 2;
  total_size += 1 * this->previoussessions_size();
  for (int i = 0; i < this->previoussessions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->previoussessions(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecordStructure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RecordStructure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RecordStructure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RecordStructure::MergeFrom(const RecordStructure& from) {
  GOOGLE_CHECK_NE(&from, this);
  previoussessions_.MergeFrom(from.previoussessions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_currentsession()) {
      mutable_currentsession()->::textsecure::SessionStructure::MergeFrom(from.currentsession());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RecordStructure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RecordStructure::CopyFrom(const RecordStructure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecordStructure::IsInitialized() const {

  return true;
}

void RecordStructure::Swap(RecordStructure* other) {
  if (other != this) {
    std::swap(currentsession_, other->currentsession_);
    previoussessions_.Swap(&other->previoussessions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RecordStructure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RecordStructure_descriptor_;
  metadata.reflection = RecordStructure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PreKeyRecordStructure::kIdFieldNumber;
const int PreKeyRecordStructure::kPublicKeyFieldNumber;
const int PreKeyRecordStructure::kPrivateKeyFieldNumber;
#endif  // !_MSC_VER

PreKeyRecordStructure::PreKeyRecordStructure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PreKeyRecordStructure::InitAsDefaultInstance() {
}

PreKeyRecordStructure::PreKeyRecordStructure(const PreKeyRecordStructure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PreKeyRecordStructure::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PreKeyRecordStructure::~PreKeyRecordStructure() {
  SharedDtor();
}

void PreKeyRecordStructure::SharedDtor() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (this != default_instance_) {
  }
}

void PreKeyRecordStructure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PreKeyRecordStructure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PreKeyRecordStructure_descriptor_;
}

const PreKeyRecordStructure& PreKeyRecordStructure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

PreKeyRecordStructure* PreKeyRecordStructure::default_instance_ = NULL;

PreKeyRecordStructure* PreKeyRecordStructure::New() const {
  return new PreKeyRecordStructure;
}

void PreKeyRecordStructure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    if (has_publickey()) {
      if (publickey_ != &::google::protobuf::internal::kEmptyString) {
        publickey_->clear();
      }
    }
    if (has_privatekey()) {
      if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
        privatekey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PreKeyRecordStructure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_publicKey;
        break;
      }

      // optional bytes publicKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_publicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_publickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_privateKey;
        break;
      }

      // optional bytes privateKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_privateKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_privatekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PreKeyRecordStructure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional bytes publicKey = 2;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->publickey(), output);
  }

  // optional bytes privateKey = 3;
  if (has_privatekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->privatekey(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PreKeyRecordStructure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional bytes publicKey = 2;
  if (has_publickey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->publickey(), target);
  }

  // optional bytes privateKey = 3;
  if (has_privatekey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->privatekey(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PreKeyRecordStructure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional bytes publicKey = 2;
    if (has_publickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->publickey());
    }

    // optional bytes privateKey = 3;
    if (has_privatekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->privatekey());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PreKeyRecordStructure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PreKeyRecordStructure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PreKeyRecordStructure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PreKeyRecordStructure::MergeFrom(const PreKeyRecordStructure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_publickey()) {
      set_publickey(from.publickey());
    }
    if (from.has_privatekey()) {
      set_privatekey(from.privatekey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PreKeyRecordStructure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PreKeyRecordStructure::CopyFrom(const PreKeyRecordStructure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PreKeyRecordStructure::IsInitialized() const {

  return true;
}

void PreKeyRecordStructure::Swap(PreKeyRecordStructure* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(publickey_, other->publickey_);
    std::swap(privatekey_, other->privatekey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PreKeyRecordStructure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PreKeyRecordStructure_descriptor_;
  metadata.reflection = PreKeyRecordStructure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignedPreKeyRecordStructure::kIdFieldNumber;
const int SignedPreKeyRecordStructure::kPublicKeyFieldNumber;
const int SignedPreKeyRecordStructure::kPrivateKeyFieldNumber;
const int SignedPreKeyRecordStructure::kSignatureFieldNumber;
const int SignedPreKeyRecordStructure::kTimestampFieldNumber;
#endif  // !_MSC_VER

SignedPreKeyRecordStructure::SignedPreKeyRecordStructure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SignedPreKeyRecordStructure::InitAsDefaultInstance() {
}

SignedPreKeyRecordStructure::SignedPreKeyRecordStructure(const SignedPreKeyRecordStructure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignedPreKeyRecordStructure::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedPreKeyRecordStructure::~SignedPreKeyRecordStructure() {
  SharedDtor();
}

void SignedPreKeyRecordStructure::SharedDtor() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void SignedPreKeyRecordStructure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedPreKeyRecordStructure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignedPreKeyRecordStructure_descriptor_;
}

const SignedPreKeyRecordStructure& SignedPreKeyRecordStructure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SignedPreKeyRecordStructure* SignedPreKeyRecordStructure::default_instance_ = NULL;

SignedPreKeyRecordStructure* SignedPreKeyRecordStructure::New() const {
  return new SignedPreKeyRecordStructure;
}

void SignedPreKeyRecordStructure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    if (has_publickey()) {
      if (publickey_ != &::google::protobuf::internal::kEmptyString) {
        publickey_->clear();
      }
    }
    if (has_privatekey()) {
      if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
        privatekey_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    timestamp_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignedPreKeyRecordStructure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_publicKey;
        break;
      }

      // optional bytes publicKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_publicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_publickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_privateKey;
        break;
      }

      // optional bytes privateKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_privateKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_privatekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_signature;
        break;
      }

      // optional bytes signature = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_timestamp;
        break;
      }

      // optional fixed64 timestamp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignedPreKeyRecordStructure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional bytes publicKey = 2;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->publickey(), output);
  }

  // optional bytes privateKey = 3;
  if (has_privatekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->privatekey(), output);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->signature(), output);
  }

  // optional fixed64 timestamp = 5;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(5, this->timestamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignedPreKeyRecordStructure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional bytes publicKey = 2;
  if (has_publickey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->publickey(), target);
  }

  // optional bytes privateKey = 3;
  if (has_privatekey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->privatekey(), target);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature(), target);
  }

  // optional fixed64 timestamp = 5;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(5, this->timestamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignedPreKeyRecordStructure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional bytes publicKey = 2;
    if (has_publickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->publickey());
    }

    // optional bytes privateKey = 3;
    if (has_privatekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->privatekey());
    }

    // optional bytes signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional fixed64 timestamp = 5;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedPreKeyRecordStructure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignedPreKeyRecordStructure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignedPreKeyRecordStructure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignedPreKeyRecordStructure::MergeFrom(const SignedPreKeyRecordStructure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_publickey()) {
      set_publickey(from.publickey());
    }
    if (from.has_privatekey()) {
      set_privatekey(from.privatekey());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignedPreKeyRecordStructure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedPreKeyRecordStructure::CopyFrom(const SignedPreKeyRecordStructure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedPreKeyRecordStructure::IsInitialized() const {

  return true;
}

void SignedPreKeyRecordStructure::Swap(SignedPreKeyRecordStructure* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(publickey_, other->publickey_);
    std::swap(privatekey_, other->privatekey_);
    std::swap(signature_, other->signature_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignedPreKeyRecordStructure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignedPreKeyRecordStructure_descriptor_;
  metadata.reflection = SignedPreKeyRecordStructure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IdentityKeyPairStructure::kPublicKeyFieldNumber;
const int IdentityKeyPairStructure::kPrivateKeyFieldNumber;
#endif  // !_MSC_VER

IdentityKeyPairStructure::IdentityKeyPairStructure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IdentityKeyPairStructure::InitAsDefaultInstance() {
}

IdentityKeyPairStructure::IdentityKeyPairStructure(const IdentityKeyPairStructure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IdentityKeyPairStructure::SharedCtor() {
  _cached_size_ = 0;
  publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IdentityKeyPairStructure::~IdentityKeyPairStructure() {
  SharedDtor();
}

void IdentityKeyPairStructure::SharedDtor() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (this != default_instance_) {
  }
}

void IdentityKeyPairStructure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IdentityKeyPairStructure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IdentityKeyPairStructure_descriptor_;
}

const IdentityKeyPairStructure& IdentityKeyPairStructure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

IdentityKeyPairStructure* IdentityKeyPairStructure::default_instance_ = NULL;

IdentityKeyPairStructure* IdentityKeyPairStructure::New() const {
  return new IdentityKeyPairStructure;
}

void IdentityKeyPairStructure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_publickey()) {
      if (publickey_ != &::google::protobuf::internal::kEmptyString) {
        publickey_->clear();
      }
    }
    if (has_privatekey()) {
      if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
        privatekey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IdentityKeyPairStructure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes publicKey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_publickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_privateKey;
        break;
      }

      // optional bytes privateKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_privateKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_privatekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IdentityKeyPairStructure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes publicKey = 1;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->publickey(), output);
  }

  // optional bytes privateKey = 2;
  if (has_privatekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->privatekey(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IdentityKeyPairStructure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes publicKey = 1;
  if (has_publickey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->publickey(), target);
  }

  // optional bytes privateKey = 2;
  if (has_privatekey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->privatekey(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IdentityKeyPairStructure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes publicKey = 1;
    if (has_publickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->publickey());
    }

    // optional bytes privateKey = 2;
    if (has_privatekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->privatekey());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IdentityKeyPairStructure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IdentityKeyPairStructure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IdentityKeyPairStructure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IdentityKeyPairStructure::MergeFrom(const IdentityKeyPairStructure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_publickey()) {
      set_publickey(from.publickey());
    }
    if (from.has_privatekey()) {
      set_privatekey(from.privatekey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IdentityKeyPairStructure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IdentityKeyPairStructure::CopyFrom(const IdentityKeyPairStructure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IdentityKeyPairStructure::IsInitialized() const {

  return true;
}

void IdentityKeyPairStructure::Swap(IdentityKeyPairStructure* other) {
  if (other != this) {
    std::swap(publickey_, other->publickey_);
    std::swap(privatekey_, other->privatekey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IdentityKeyPairStructure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IdentityKeyPairStructure_descriptor_;
  metadata.reflection = IdentityKeyPairStructure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SenderKeyStateStructure_SenderChainKey::kIterationFieldNumber;
const int SenderKeyStateStructure_SenderChainKey::kSeedFieldNumber;
#endif  // !_MSC_VER

SenderKeyStateStructure_SenderChainKey::SenderKeyStateStructure_SenderChainKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SenderKeyStateStructure_SenderChainKey::InitAsDefaultInstance() {
}

SenderKeyStateStructure_SenderChainKey::SenderKeyStateStructure_SenderChainKey(const SenderKeyStateStructure_SenderChainKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SenderKeyStateStructure_SenderChainKey::SharedCtor() {
  _cached_size_ = 0;
  iteration_ = 0u;
  seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SenderKeyStateStructure_SenderChainKey::~SenderKeyStateStructure_SenderChainKey() {
  SharedDtor();
}

void SenderKeyStateStructure_SenderChainKey::SharedDtor() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (this != default_instance_) {
  }
}

void SenderKeyStateStructure_SenderChainKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SenderKeyStateStructure_SenderChainKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SenderKeyStateStructure_SenderChainKey_descriptor_;
}

const SenderKeyStateStructure_SenderChainKey& SenderKeyStateStructure_SenderChainKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SenderKeyStateStructure_SenderChainKey* SenderKeyStateStructure_SenderChainKey::default_instance_ = NULL;

SenderKeyStateStructure_SenderChainKey* SenderKeyStateStructure_SenderChainKey::New() const {
  return new SenderKeyStateStructure_SenderChainKey;
}

void SenderKeyStateStructure_SenderChainKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    iteration_ = 0u;
    if (has_seed()) {
      if (seed_ != &::google::protobuf::internal::kEmptyString) {
        seed_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SenderKeyStateStructure_SenderChainKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 iteration = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &iteration_)));
          set_has_iteration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_seed;
        break;
      }

      // optional bytes seed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_seed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SenderKeyStateStructure_SenderChainKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 iteration = 1;
  if (has_iteration()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->iteration(), output);
  }

  // optional bytes seed = 2;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->seed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SenderKeyStateStructure_SenderChainKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 iteration = 1;
  if (has_iteration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->iteration(), target);
  }

  // optional bytes seed = 2;
  if (has_seed()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->seed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SenderKeyStateStructure_SenderChainKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 iteration = 1;
    if (has_iteration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->iteration());
    }

    // optional bytes seed = 2;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SenderKeyStateStructure_SenderChainKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SenderKeyStateStructure_SenderChainKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SenderKeyStateStructure_SenderChainKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SenderKeyStateStructure_SenderChainKey::MergeFrom(const SenderKeyStateStructure_SenderChainKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_iteration()) {
      set_iteration(from.iteration());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SenderKeyStateStructure_SenderChainKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SenderKeyStateStructure_SenderChainKey::CopyFrom(const SenderKeyStateStructure_SenderChainKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SenderKeyStateStructure_SenderChainKey::IsInitialized() const {

  return true;
}

void SenderKeyStateStructure_SenderChainKey::Swap(SenderKeyStateStructure_SenderChainKey* other) {
  if (other != this) {
    std::swap(iteration_, other->iteration_);
    std::swap(seed_, other->seed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SenderKeyStateStructure_SenderChainKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SenderKeyStateStructure_SenderChainKey_descriptor_;
  metadata.reflection = SenderKeyStateStructure_SenderChainKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SenderKeyStateStructure_SenderMessageKey::kIterationFieldNumber;
const int SenderKeyStateStructure_SenderMessageKey::kSeedFieldNumber;
#endif  // !_MSC_VER

SenderKeyStateStructure_SenderMessageKey::SenderKeyStateStructure_SenderMessageKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SenderKeyStateStructure_SenderMessageKey::InitAsDefaultInstance() {
}

SenderKeyStateStructure_SenderMessageKey::SenderKeyStateStructure_SenderMessageKey(const SenderKeyStateStructure_SenderMessageKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SenderKeyStateStructure_SenderMessageKey::SharedCtor() {
  _cached_size_ = 0;
  iteration_ = 0u;
  seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SenderKeyStateStructure_SenderMessageKey::~SenderKeyStateStructure_SenderMessageKey() {
  SharedDtor();
}

void SenderKeyStateStructure_SenderMessageKey::SharedDtor() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (this != default_instance_) {
  }
}

void SenderKeyStateStructure_SenderMessageKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SenderKeyStateStructure_SenderMessageKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SenderKeyStateStructure_SenderMessageKey_descriptor_;
}

const SenderKeyStateStructure_SenderMessageKey& SenderKeyStateStructure_SenderMessageKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SenderKeyStateStructure_SenderMessageKey* SenderKeyStateStructure_SenderMessageKey::default_instance_ = NULL;

SenderKeyStateStructure_SenderMessageKey* SenderKeyStateStructure_SenderMessageKey::New() const {
  return new SenderKeyStateStructure_SenderMessageKey;
}

void SenderKeyStateStructure_SenderMessageKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    iteration_ = 0u;
    if (has_seed()) {
      if (seed_ != &::google::protobuf::internal::kEmptyString) {
        seed_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SenderKeyStateStructure_SenderMessageKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 iteration = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &iteration_)));
          set_has_iteration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_seed;
        break;
      }

      // optional bytes seed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_seed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SenderKeyStateStructure_SenderMessageKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 iteration = 1;
  if (has_iteration()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->iteration(), output);
  }

  // optional bytes seed = 2;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->seed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SenderKeyStateStructure_SenderMessageKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 iteration = 1;
  if (has_iteration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->iteration(), target);
  }

  // optional bytes seed = 2;
  if (has_seed()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->seed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SenderKeyStateStructure_SenderMessageKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 iteration = 1;
    if (has_iteration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->iteration());
    }

    // optional bytes seed = 2;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SenderKeyStateStructure_SenderMessageKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SenderKeyStateStructure_SenderMessageKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SenderKeyStateStructure_SenderMessageKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SenderKeyStateStructure_SenderMessageKey::MergeFrom(const SenderKeyStateStructure_SenderMessageKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_iteration()) {
      set_iteration(from.iteration());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SenderKeyStateStructure_SenderMessageKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SenderKeyStateStructure_SenderMessageKey::CopyFrom(const SenderKeyStateStructure_SenderMessageKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SenderKeyStateStructure_SenderMessageKey::IsInitialized() const {

  return true;
}

void SenderKeyStateStructure_SenderMessageKey::Swap(SenderKeyStateStructure_SenderMessageKey* other) {
  if (other != this) {
    std::swap(iteration_, other->iteration_);
    std::swap(seed_, other->seed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SenderKeyStateStructure_SenderMessageKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SenderKeyStateStructure_SenderMessageKey_descriptor_;
  metadata.reflection = SenderKeyStateStructure_SenderMessageKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SenderKeyStateStructure_SenderSigningKey::kPublicFieldNumber;
const int SenderKeyStateStructure_SenderSigningKey::kPrivateFieldNumber;
#endif  // !_MSC_VER

SenderKeyStateStructure_SenderSigningKey::SenderKeyStateStructure_SenderSigningKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SenderKeyStateStructure_SenderSigningKey::InitAsDefaultInstance() {
}

SenderKeyStateStructure_SenderSigningKey::SenderKeyStateStructure_SenderSigningKey(const SenderKeyStateStructure_SenderSigningKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SenderKeyStateStructure_SenderSigningKey::SharedCtor() {
  _cached_size_ = 0;
  public__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  private__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SenderKeyStateStructure_SenderSigningKey::~SenderKeyStateStructure_SenderSigningKey() {
  SharedDtor();
}

void SenderKeyStateStructure_SenderSigningKey::SharedDtor() {
  if (public__ != &::google::protobuf::internal::kEmptyString) {
    delete public__;
  }
  if (private__ != &::google::protobuf::internal::kEmptyString) {
    delete private__;
  }
  if (this != default_instance_) {
  }
}

void SenderKeyStateStructure_SenderSigningKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SenderKeyStateStructure_SenderSigningKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SenderKeyStateStructure_SenderSigningKey_descriptor_;
}

const SenderKeyStateStructure_SenderSigningKey& SenderKeyStateStructure_SenderSigningKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SenderKeyStateStructure_SenderSigningKey* SenderKeyStateStructure_SenderSigningKey::default_instance_ = NULL;

SenderKeyStateStructure_SenderSigningKey* SenderKeyStateStructure_SenderSigningKey::New() const {
  return new SenderKeyStateStructure_SenderSigningKey;
}

void SenderKeyStateStructure_SenderSigningKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_public_()) {
      if (public__ != &::google::protobuf::internal::kEmptyString) {
        public__->clear();
      }
    }
    if (has_private_()) {
      if (private__ != &::google::protobuf::internal::kEmptyString) {
        private__->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SenderKeyStateStructure_SenderSigningKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes public = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_private;
        break;
      }

      // optional bytes private = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_private:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_private_()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SenderKeyStateStructure_SenderSigningKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes public = 1;
  if (has_public_()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->public_(), output);
  }

  // optional bytes private = 2;
  if (has_private_()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->private_(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SenderKeyStateStructure_SenderSigningKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes public = 1;
  if (has_public_()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->public_(), target);
  }

  // optional bytes private = 2;
  if (has_private_()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->private_(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SenderKeyStateStructure_SenderSigningKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes public = 1;
    if (has_public_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_());
    }

    // optional bytes private = 2;
    if (has_private_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->private_());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SenderKeyStateStructure_SenderSigningKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SenderKeyStateStructure_SenderSigningKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SenderKeyStateStructure_SenderSigningKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SenderKeyStateStructure_SenderSigningKey::MergeFrom(const SenderKeyStateStructure_SenderSigningKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_public_()) {
      set_public_(from.public_());
    }
    if (from.has_private_()) {
      set_private_(from.private_());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SenderKeyStateStructure_SenderSigningKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SenderKeyStateStructure_SenderSigningKey::CopyFrom(const SenderKeyStateStructure_SenderSigningKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SenderKeyStateStructure_SenderSigningKey::IsInitialized() const {

  return true;
}

void SenderKeyStateStructure_SenderSigningKey::Swap(SenderKeyStateStructure_SenderSigningKey* other) {
  if (other != this) {
    std::swap(public__, other->public__);
    std::swap(private__, other->private__);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SenderKeyStateStructure_SenderSigningKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SenderKeyStateStructure_SenderSigningKey_descriptor_;
  metadata.reflection = SenderKeyStateStructure_SenderSigningKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SenderKeyStateStructure::kSenderKeyIdFieldNumber;
const int SenderKeyStateStructure::kSenderChainKeyFieldNumber;
const int SenderKeyStateStructure::kSenderSigningKeyFieldNumber;
const int SenderKeyStateStructure::kSenderMessageKeysFieldNumber;
#endif  // !_MSC_VER

SenderKeyStateStructure::SenderKeyStateStructure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SenderKeyStateStructure::InitAsDefaultInstance() {
  senderchainkey_ = const_cast< ::textsecure::SenderKeyStateStructure_SenderChainKey*>(&::textsecure::SenderKeyStateStructure_SenderChainKey::default_instance());
  sendersigningkey_ = const_cast< ::textsecure::SenderKeyStateStructure_SenderSigningKey*>(&::textsecure::SenderKeyStateStructure_SenderSigningKey::default_instance());
}

SenderKeyStateStructure::SenderKeyStateStructure(const SenderKeyStateStructure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SenderKeyStateStructure::SharedCtor() {
  _cached_size_ = 0;
  senderkeyid_ = 0u;
  senderchainkey_ = NULL;
  sendersigningkey_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SenderKeyStateStructure::~SenderKeyStateStructure() {
  SharedDtor();
}

void SenderKeyStateStructure::SharedDtor() {
  if (this != default_instance_) {
    delete senderchainkey_;
    delete sendersigningkey_;
  }
}

void SenderKeyStateStructure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SenderKeyStateStructure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SenderKeyStateStructure_descriptor_;
}

const SenderKeyStateStructure& SenderKeyStateStructure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SenderKeyStateStructure* SenderKeyStateStructure::default_instance_ = NULL;

SenderKeyStateStructure* SenderKeyStateStructure::New() const {
  return new SenderKeyStateStructure;
}

void SenderKeyStateStructure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    senderkeyid_ = 0u;
    if (has_senderchainkey()) {
      if (senderchainkey_ != NULL) senderchainkey_->::textsecure::SenderKeyStateStructure_SenderChainKey::Clear();
    }
    if (has_sendersigningkey()) {
      if (sendersigningkey_ != NULL) sendersigningkey_->::textsecure::SenderKeyStateStructure_SenderSigningKey::Clear();
    }
  }
  sendermessagekeys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SenderKeyStateStructure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 senderKeyId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &senderkeyid_)));
          set_has_senderkeyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_senderChainKey;
        break;
      }

      // optional .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_senderChainKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_senderchainkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_senderSigningKey;
        break;
      }

      // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_senderSigningKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sendersigningkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_senderMessageKeys;
        break;
      }

      // repeated .textsecure.SenderKeyStateStructure.SenderMessageKey senderMessageKeys = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_senderMessageKeys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sendermessagekeys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_senderMessageKeys;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SenderKeyStateStructure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 senderKeyId = 1;
  if (has_senderkeyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->senderkeyid(), output);
  }

  // optional .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKey = 2;
  if (has_senderchainkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->senderchainkey(), output);
  }

  // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
  if (has_sendersigningkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sendersigningkey(), output);
  }

  // repeated .textsecure.SenderKeyStateStructure.SenderMessageKey senderMessageKeys = 4;
  for (int i = 0; i < this->sendermessagekeys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->sendermessagekeys(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SenderKeyStateStructure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 senderKeyId = 1;
  if (has_senderkeyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->senderkeyid(), target);
  }

  // optional .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKey = 2;
  if (has_senderchainkey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->senderchainkey(), target);
  }

  // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
  if (has_sendersigningkey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sendersigningkey(), target);
  }

  // repeated .textsecure.SenderKeyStateStructure.SenderMessageKey senderMessageKeys = 4;
  for (int i = 0; i < this->sendermessagekeys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->sendermessagekeys(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SenderKeyStateStructure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 senderKeyId = 1;
    if (has_senderkeyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->senderkeyid());
    }

    // optional .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKey = 2;
    if (has_senderchainkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->senderchainkey());
    }

    // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
    if (has_sendersigningkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sendersigningkey());
    }

  }
  // repeated .textsecure.SenderKeyStateStructure.SenderMessageKey senderMessageKeys = 4;
  total_size += 1 * this->sendermessagekeys_size();
  for (int i = 0; i < this->sendermessagekeys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sendermessagekeys(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SenderKeyStateStructure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SenderKeyStateStructure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SenderKeyStateStructure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SenderKeyStateStructure::MergeFrom(const SenderKeyStateStructure& from) {
  GOOGLE_CHECK_NE(&from, this);
  sendermessagekeys_.MergeFrom(from.sendermessagekeys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_senderkeyid()) {
      set_senderkeyid(from.senderkeyid());
    }
    if (from.has_senderchainkey()) {
      mutable_senderchainkey()->::textsecure::SenderKeyStateStructure_SenderChainKey::MergeFrom(from.senderchainkey());
    }
    if (from.has_sendersigningkey()) {
      mutable_sendersigningkey()->::textsecure::SenderKeyStateStructure_SenderSigningKey::MergeFrom(from.sendersigningkey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SenderKeyStateStructure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SenderKeyStateStructure::CopyFrom(const SenderKeyStateStructure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SenderKeyStateStructure::IsInitialized() const {

  return true;
}

void SenderKeyStateStructure::Swap(SenderKeyStateStructure* other) {
  if (other != this) {
    std::swap(senderkeyid_, other->senderkeyid_);
    std::swap(senderchainkey_, other->senderchainkey_);
    std::swap(sendersigningkey_, other->sendersigningkey_);
    sendermessagekeys_.Swap(&other->sendermessagekeys_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SenderKeyStateStructure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SenderKeyStateStructure_descriptor_;
  metadata.reflection = SenderKeyStateStructure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SenderKeyRecordStructure::kSenderKeyStatesFieldNumber;
#endif  // !_MSC_VER

SenderKeyRecordStructure::SenderKeyRecordStructure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SenderKeyRecordStructure::InitAsDefaultInstance() {
}

SenderKeyRecordStructure::SenderKeyRecordStructure(const SenderKeyRecordStructure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SenderKeyRecordStructure::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SenderKeyRecordStructure::~SenderKeyRecordStructure() {
  SharedDtor();
}

void SenderKeyRecordStructure::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SenderKeyRecordStructure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SenderKeyRecordStructure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SenderKeyRecordStructure_descriptor_;
}

const SenderKeyRecordStructure& SenderKeyRecordStructure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protobuf_2fLocalStorageProtocol_2eproto();
  return *default_instance_;
}

SenderKeyRecordStructure* SenderKeyRecordStructure::default_instance_ = NULL;

SenderKeyRecordStructure* SenderKeyRecordStructure::New() const {
  return new SenderKeyRecordStructure;
}

void SenderKeyRecordStructure::Clear() {
  senderkeystates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SenderKeyRecordStructure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .textsecure.SenderKeyStateStructure senderKeyStates = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_senderKeyStates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_senderkeystates()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_senderKeyStates;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SenderKeyRecordStructure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .textsecure.SenderKeyStateStructure senderKeyStates = 1;
  for (int i = 0; i < this->senderkeystates_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->senderkeystates(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SenderKeyRecordStructure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .textsecure.SenderKeyStateStructure senderKeyStates = 1;
  for (int i = 0; i < this->senderkeystates_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->senderkeystates(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SenderKeyRecordStructure::ByteSize() const {
  int total_size = 0;

  // repeated .textsecure.SenderKeyStateStructure senderKeyStates = 1;
  total_size += 1 * this->senderkeystates_size();
  for (int i = 0; i < this->senderkeystates_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->senderkeystates(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SenderKeyRecordStructure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SenderKeyRecordStructure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SenderKeyRecordStructure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SenderKeyRecordStructure::MergeFrom(const SenderKeyRecordStructure& from) {
  GOOGLE_CHECK_NE(&from, this);
  senderkeystates_.MergeFrom(from.senderkeystates_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SenderKeyRecordStructure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SenderKeyRecordStructure::CopyFrom(const SenderKeyRecordStructure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SenderKeyRecordStructure::IsInitialized() const {

  return true;
}

void SenderKeyRecordStructure::Swap(SenderKeyRecordStructure* other) {
  if (other != this) {
    senderkeystates_.Swap(&other->senderkeystates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SenderKeyRecordStructure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SenderKeyRecordStructure_descriptor_;
  metadata.reflection = SenderKeyRecordStructure_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace textsecure

// @@protoc_insertion_point(global_scope)
